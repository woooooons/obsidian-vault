---
title: 클린코드 이론
date: 2025-12-03
tags:
  - it
  - 개발
  - 클린코드
---
# 클린 코드 완벽 가이드

## 1. 클린 코드란 무엇인가?

클린 코드는 **읽기 쉽고, 이해하기 쉽고, 수정하기 쉬운 코드**입니다. 로버트 C. 마틴(Robert C. Martin, Uncle Bob)은 "클린 코드는 잘 쓰여진 산문처럼 읽혀야 한다"고 말했습니다.

### 클린 코드의 핵심 특징

- **명확성**: 코드의 의도가 즉시 이해됨
- **단순성**: 불필요한 복잡성이 없음
- **표현력**: 코드 자체가 문서 역할을 함
- **최소 의존성**: 다른 코드와의 결합도가 낮음
- **테스트 가능성**: 쉽게 테스트할 수 있음

## 2. 의미 있는 이름 짓기

### 2.1 이름에 의도를 드러내라

**나쁜 예:**


```python
d = 86400  # 하루의 초
t = time.time()
l = [1, 2, 3, 4, 5]
```

**좋은 예:**


```python
SECONDS_PER_DAY = 86400
current_timestamp = time.time()
prime_numbers = [1, 2, 3, 4, 5]
```

### 2.2 그릇된 정보를 피하라

**나쁜 예:**


```python
accountList = {}  # 실제로는 dict인데 List라고 명명
hp = "hyper text"  # hp는 보통 hitpoints를 연상
```

**좋은 예:**


```python
account_map = {}
hypertext_protocol = "hyper text"
```

### 2.3 의미 있게 구분하라

**나쁜 예:**


```python
def copy_string(a1, a2):
    for i in range(len(a1)):
        a2[i] = a1[i]

# Product, ProductInfo, ProductData 뭐가 다른가?
class Product:
    pass

class ProductInfo:
    pass
```

**좋은 예:**


```python
def copy_string(source, destination):
    for i in range(len(source)):
        destination[i] = source[i]

class Product:  # 제품 엔티티
    pass

class ProductSpecification:  # 제품 상세 스펙
    pass
```

### 2.4 발음하기 쉬운 이름을 사용하라

**나쁜 예:**


```python
genymdhms = datetime.now()  # generation year month day hour minute second
modymdhms = datetime.now()  # modification...
```

**좋은 예:**


```python
generation_timestamp = datetime.now()
modification_timestamp = datetime.now()
```

### 2.5 검색하기 쉬운 이름을 사용하라

**나쁜 예:**


```python
# 숫자 7이 뭘 의미하는지 검색하기 어려움
for i in range(7):
    work_days.append(i)
```

**좋은 예:**


```python
WORK_DAYS_PER_WEEK = 7
for day in range(WORK_DAYS_PER_WEEK):
    work_days.append(day)
```

### 2.6 클래스와 메서드 이름 규칙

**클래스명**: 명사 또는 명사구


```python
class Customer:
    pass

class AccountManager:
    pass

class PaymentProcessor:
    pass
```

**메서드명**: 동사 또는 동사구


```python
def get_user():
    pass

def save_order():
    pass

def is_valid():
    pass

def has_permission():
    pass
```

## 3. 함수 (Functions)

### 3.1 작게 만들어라

함수는 **한 가지 일만** 해야 하며, 그 일을 **잘** 해야 합니다.

**나쁜 예:**


```python
def process_user_order(user_id, items):
    # 사용자 검증
    user = db.query(f"SELECT * FROM users WHERE id={user_id}")
    if not user:
        return {"error": "User not found"}
    
    # 재고 확인
    for item in items:
        stock = db.query(f"SELECT quantity FROM inventory WHERE id={item['id']}")
        if stock < item['quantity']:
            return {"error": "Insufficient stock"}
    
    # 가격 계산
    total = 0
    for item in items:
        price = db.query(f"SELECT price FROM products WHERE id={item['id']}")
        total += price * item['quantity']
    
    # 할인 적용
    if user['membership'] == 'gold':
        total *= 0.9
    elif user['membership'] == 'silver':
        total *= 0.95
    
    # 주문 생성
    order_id = db.insert(f"INSERT INTO orders VALUES ...")
    
    # 이메일 발송
    send_email(user['email'], f"Order {order_id} confirmed")
    
    # 재고 차감
    for item in items:
        db.update(f"UPDATE inventory SET quantity=quantity-{item['quantity']}")
    
    return {"order_id": order_id, "total": total}
```

**좋은 예:**


```python
def process_user_order(user_id, items):
    user = validate_user(user_id)
    validate_stock(items)
    
    total = calculate_total_price(items)
    discounted_total = apply_membership_discount(user, total)
    
    order = create_order(user_id, items, discounted_total)
    
    update_inventory(items)
    send_order_confirmation_email(user.email, order.id)
    
    return order

def validate_user(user_id):
    user = user_repository.find_by_id(user_id)
    if not user:
        raise UserNotFoundException(user_id)
    return user

def validate_stock(items):
    for item in items:
        if not inventory_service.has_sufficient_stock(item):
            raise InsufficientStockException(item)

def calculate_total_price(items):
    return sum(item.price * item.quantity for item in items)

def apply_membership_discount(user, total):
    discount_rate = membership_service.get_discount_rate(user.membership)
    return total * (1 - discount_rate)
```

### 3.2 함수 인수

이상적인 인수 개수는 **0개(무항)**입니다. 다음은 **1개(단항)**, 다음은 **2개(이항)**입니다. 3개 이상은 피하세요.

**나쁜 예:**


```python
def create_user(name, email, age, address, phone, city, country, postal_code):
    pass
```

**좋은 예:**


```python
class UserInfo:
    def __init__(self, name, email, age, contact_info):
        self.name = name
        self.email = email
        self.age = age
        self.contact_info = contact_info

class ContactInfo:
    def __init__(self, phone, address):
        self.phone = phone
        self.address = address

def create_user(user_info):
    pass
```

### 3.3 부수 효과를 일으키지 마라

**나쁜 예:**


```python
def check_password(username, password):
    user = db.find_user(username)
    if user.password == password:
        session.initialize()  # 부수 효과!
        return True
    return False
```

**좋은 예:**


```python
def check_password(username, password):
    user = db.find_user(username)
    return user.password == password

def login(username, password):
    if check_password(username, password):
        session.initialize()
        return True
    return False
```

### 3.4 명령과 조회를 분리하라

**나쁜 예:**


```python
def set_and_check_attribute(attribute, value):
    # 값을 설정하고 설정 성공 여부를 반환
    if attribute_exists(attribute):
        set_attribute(attribute, value)
        return True
    return False

# 사용 시 혼란스러움
if set_and_check_attribute("username", "john"):
    # 이게 체크인가? 설정인가?
    pass
```

**좋은 예:**


```python
def set_attribute(attribute, value):
    if not attribute_exists(attribute):
        raise AttributeNotFoundException(attribute)
    # 값 설정
    attributes[attribute] = value

def attribute_exists(attribute):
    return attribute in attributes

# 명확한 사용
if attribute_exists("username"):
    set_attribute("username", "john")
```

### 3.5 오류 코드보다 예외를 사용하라

**나쁜 예:**


```python
def delete_page(page):
    if delete_page_from_db(page) == E_OK:
        if registry.delete_reference(page) == E_OK:
            if config_keys.delete_key(page.name) == E_OK:
                logger.log("page deleted")
            else:
                logger.log("config key delete failed")
        else:
            logger.log("delete reference failed")
    else:
        logger.log("delete failed")
```

**좋은 예:**


```python
def delete_page(page):
    try:
        delete_page_and_all_references(page)
        logger.log("page deleted")
    except Exception as e:
        logger.log_error(e)

def delete_page_and_all_references(page):
    delete_page_from_db(page)
    registry.delete_reference(page)
    config_keys.delete_key(page.name)
```

### 3.6 Try/Catch 블록 추출하기

**나쁜 예:**


```python
def process_data():
    try:
        data = fetch_data()
        validate_data(data)
        transform_data(data)
        save_data(data)
        send_notification()
    except Exception as e:
        log_error(e)
```

**좋은 예:**


```python
def process_data():
    try:
        execute_data_processing()
    except Exception as e:
        handle_processing_error(e)

def execute_data_processing():
    data = fetch_data()
    validate_data(data)
    transform_data(data)
    save_data(data)
    send_notification()

def handle_processing_error(error):
    log_error(error)
    notify_admin(error)
```

## 4. 주석 (Comments)

### 4.1 좋은 주석

**법적 주석:**


```python
# Copyright (C) 2024 Company Inc.
# Licensed under the Apache License, Version 2.0
```

**정보를 제공하는 주석:**


```python
# 정규식: kk:mm:ss EEE, MMM dd, yyyy 형식과 매칭
pattern = re.compile(r'\d{2}:\d{2}:\d{2} \w{3}, \w{3} \d{2}, \d{4}')
```

**의도를 설명하는 주석:**


```python
def compare_to(other):
    # 더 높은 우선순위를 가진 항목이 먼저 오도록 정렬
    # 같은 우선순위라면 나중에 생성된 것이 먼저 오도록
    if self.priority != other.priority:
        return other.priority - self.priority
    return other.created_at - self.created_at
```

**경고 주석:**


```python
# 주의: 이 테스트는 실행하는데 10분이 걸립니다
def test_with_large_dataset():
    pass

# TODO: 현재는 메모리에만 저장하지만, 나중에 데이터베이스로 이전 필요
cache = {}
```

### 4.2 나쁜 주석

**있으나 마나 한 주석:**


```python
# 나쁜 예
i = 0  # i를 0으로 초기화

# 좋은 예 (주석 없이)
current_index = 0
```

**함수나 변수로 표현할 수 있다면 주석 대신 표현하라:**


```python
# 나쁜 예
# 직원이 복지 혜택을 받을 자격이 있는지 확인
if (employee.flags & HOURLY_FLAG) and (employee.age > 65):
    pass

# 좋은 예
if employee.is_eligible_for_benefits():
    pass
```

**닫는 괄호에 다는 주석:**


```python
# 나쁜 예
while condition:
    if another_condition:
        for item in items:
            do_something()
        # for
    # if
# while

# 좋은 예: 함수를 작게 만들면 불필요
```

**주석으로 처리한 코드:**


```python
# 나쁜 예
def process():
    calculate()
    # old_calculate()  # 이전 버전
    # legacy_process()  # 레거시
    finalize()

# 좋은 예: 버전 관리 시스템에 맡기고 삭제
def process():
    calculate()
    finalize()
```

## 5. 형식 맞추기

### 5.1 적절한 행 길이 유지

- 대부분의 파일은 **200줄 미만**이어야 합니다
- 500줄을 넘어가면 리팩토링을 고려하세요

### 5.2 신문 기사처럼 작성하라


```python
# 파일 최상단: 고수준 개념
class OrderService:
    """주문 처리를 담당하는 서비스"""
    
    # 공개 메서드 (고수준)
    def process_order(self, order):
        pass
    
    def cancel_order(self, order_id):
        pass
    
    # 비공개 메서드 (저수준 상세)
    def _validate_order(self, order):
        pass
    
    def _calculate_shipping(self, order):
        pass
    
    def _send_confirmation(self, order):
        pass
```

### 5.3 개념은 빈 행으로 분리


```python
# 나쁜 예
def calculate_total():
    subtotal = 0
    for item in items:
        subtotal += item.price
    tax = subtotal * 0.1
    shipping = calculate_shipping()
    return subtotal + tax + shipping

# 좋은 예
def calculate_total():
    subtotal = calculate_subtotal()
    
    tax = calculate_tax(subtotal)
    shipping = calculate_shipping()
    
    return subtotal + tax + shipping

def calculate_subtotal():
    return sum(item.price for item in items)

def calculate_tax(subtotal):
    TAX_RATE = 0.1
    return subtotal * TAX_RATE
```

### 5.4 세로 밀집도


```python
# 나쁜 예
class User:
    
    def __init__(self):
        
        self.name = None
        
        self.email = None
        
        self.age = None

# 좋은 예
class User:
    def __init__(self):
        self.name = None
        self.email = None
        self.age = None
```

### 5.5 가로 형식

- 행 길이는 **80-120자**를 권장합니다
- 120자를 넘지 않도록 노력하세요


```python
# 나쁜 예
result = some_very_long_function_name(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7)

# 좋은 예
result = some_very_long_function_name(
    parameter1,
    parameter2,
    parameter3,
    parameter4,
    parameter5,
    parameter6,
    parameter7
)
```

## 6. 객체와 자료구조

### 6.1 자료 추상화

**나쁜 예 (구체적인 구현 노출):**


```python
class Point:
    def __init__(self):
        self.x = 0
        self.y = 0

# 직접 접근
point = Point()
point.x = 10
point.y = 20
```

**좋은 예 (추상 인터페이스 제공):**


```python
class Point:
    def __init__(self):
        self._x = 0
        self._y = 0
    
    def get_x(self):
        return self._x
    
    def get_y(self):
        return self._y
    
    def set_cartesian(self, x, y):
        self._x = x
        self._y = y
    
    def get_r(self):
        return math.sqrt(self._x**2 + self._y**2)
    
    def get_theta(self):
        return math.atan2(self._y, self._x)
    
    def set_polar(self, r, theta):
        self._x = r * math.cos(theta)
        self._y = r * math.sin(theta)
```

### 6.2 디미터 법칙 (Law of Demeter)

**"낯선 사람과 대화하지 말고, 친구하고만 대화하라"**

**나쁜 예 (기차 충돌):**


```python
# 여러 단계를 거쳐 접근
output_dir = ctxt.get_options().get_scratch_dir().get_absolute_path()
```

**좋은 예:**


```python
# 방법 1: 중간 객체들을 변수로 분리
options = ctxt.get_options()
scratch_dir = options.get_scratch_dir()
output_dir = scratch_dir.get_absolute_path()

# 방법 2: 의도를 드러내는 메서드 제공
output_dir = ctxt.get_scratch_directory_path()

# 방법 3: 최선 - 왜 그 경로가 필요한지 생각하고 직접 요청
scratch_file = ctxt.create_scratch_file_stream(class_file_name)
```

### 6.3 자료 전달 객체 (DTO)


```python
# 나쁜 예: 비즈니스 로직이 섞인 DTO
class UserDTO:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def send_welcome_email(self):  # DTO에 행위가 있으면 안됨
        pass
    
    def validate(self):  # 검증 로직도 DTO가 아닌 다른 곳에
        pass

# 좋은 예: 순수한 자료 구조
class UserDTO:
    def __init__(self, name, email, age):
        self.name = name
        self.email = email
        self.age = age

# 비즈니스 로직은 서비스에서
class UserService:
    def create_user(self, user_dto):
        self._validate_user(user_dto)
        user = User(user_dto)
        self._user_repository.save(user)
        self._email_service.send_welcome_email(user)
```

## 7. 오류 처리

### 7.1 오류 코드보다 예외 사용

**나쁜 예:**


```python
ERROR_CODE_SUCCESS = 0
ERROR_CODE_INVALID_INPUT = 1
ERROR_CODE_DB_CONNECTION_FAILED = 2

def process_data(data):
    if not validate(data):
        return ERROR_CODE_INVALID_INPUT
    
    result = save_to_db(data)
    if result != ERROR_CODE_SUCCESS:
        return result
    
    return ERROR_CODE_SUCCESS

# 호출 코드가 복잡해짐
result = process_data(data)
if result == ERROR_CODE_SUCCESS:
    print("Success")
elif result == ERROR_CODE_INVALID_INPUT:
    print("Invalid input")
```

**좋은 예:**


```python
class InvalidInputError(Exception):
    pass

class DatabaseError(Exception):
    pass

def process_data(data):
    validate(data)  # 실패 시 예외 발생
    save_to_db(data)  # 실패 시 예외 발생

# 호출 코드가 깔끔해짐
try:
    process_data(data)
    print("Success")
except InvalidInputError:
    print("Invalid input")
except DatabaseError:
    print("Database error")
```

### 7.2 예외 클래스 정의


```python
# 나쁜 예: 일반 Exception만 사용
def transfer_money(from_account, to_account, amount):
    if amount <= 0:
        raise Exception("Invalid amount")
    if from_account.balance < amount:
        raise Exception("Insufficient funds")

# 좋은 예: 의미 있는 예외 클래스
class InvalidAmountError(ValueError):
    def __init__(self, amount):
        self.amount = amount
        super().__init__(f"Invalid amount: {amount}")

class InsufficientFundsError(Exception):
    def __init__(self, balance, required):
        self.balance = balance
        self.required = required
        super().__init__(
            f"Insufficient funds: balance={balance}, required={required}"
        )

def transfer_money(from_account, to_account, amount):
    if amount <= 0:
        raise InvalidAmountError(amount)
    if from_account.balance < amount:
        raise InsufficientFundsError(from_account.balance, amount)
    
    from_account.withdraw(amount)
    to_account.deposit(amount)

# 각 예외를 구체적으로 처리 가능
try:
    transfer_money(account1, account2, -100)
except InvalidAmountError as e:
    print(f"금액이 올바르지 않습니다: {e.amount}")
except InsufficientFundsError as e:
    print(f"잔액 부족: {e.balance} < {e.required}")
```

### 7.3 예외로 흐름을 제어하지 마라

**나쁜 예:**


```python
# 정상 흐름을 예외로 제어
try:
    while True:
        item = iterator.next()
        process(item)
except StopIteration:
    pass  # 끝났음

# 좋은 예
for item in iterator:
    process(item)
```

### 7.4 Null을 반환하지 마라

**나쁜 예:**


```python
def find_user(user_id):
    user = db.query(user_id)
    if user:
        return user
    return None

# 호출하는 쪽에서 매번 None 체크 필요
user = find_user(123)
if user is not None:
    print(user.name)
```

**좋은 예:**


```python
# 방법 1: 예외 발생
class UserNotFoundError(Exception):
    pass

def find_user(user_id):
    user = db.query(user_id)
    if not user:
        raise UserNotFoundError(f"User {user_id} not found")
    return user

# 방법 2: Optional/None 객체 패턴
class NullUser:
    @property
    def name(self):
        return "Guest"
    
    def has_permission(self, permission):
        return False

def find_user(user_id):
    user = db.query(user_id)
    return user if user else NullUser()

# None 체크 없이 사용 가능
user = find_user(123)
print(user.name)  # 항상 동작
```

### 7.5 Null을 전달하지 마라

**나쁜 예:**


```python
def calculate_area(width, height):
    return width * height

# None을 전달하면 에러
calculate_area(None, 10)  # TypeError
```

**좋은 예:**


```python
def calculate_area(width, height):
    if width is None or height is None:
        raise ValueError("Width and height cannot be None")
    if width < 0 or height < 0:
        raise ValueError("Width and height must be positive")
    return width * height

# 또는 타입 힌트와 검증 사용
def calculate_area(width: float, height: float) -> float:
    assert width > 0, "Width must be positive"
    assert height > 0, "Height must be positive"
    return width * height
```

## 8. 코드 스멜 (Code Smells)

### 8.1 중복 코드 (Duplicated Code)

**나쁜 예:**


```python
def calculate_employee_salary(employee):
    base = employee.base_salary
    bonus = employee.base_salary * 0.1
    tax = (employee.base_salary + bonus) * 0.2
    return base + bonus - tax

def calculate_contractor_payment(contractor):
    base = contractor.hourly_rate * contractor.hours
    bonus = contractor.hourly_rate * contractor.hours * 0.1
    tax = (contractor.hourly_rate * contractor.hours + bonus) * 0.2
    return base + bonus - tax
```

**좋은 예:**

```python
def calculate_payment(base_amount, bonus_rate=0.1, tax_rate=0.2):
    bonus = base_amount * bonus_rate
    tax = (base_amount + bonus) * tax_rate
    return base_amount + bonus - tax

def calculate_employee_salary(employee):
    return calculate_payment(employee.base_salary)

def calculate_contractor_payment(contractor):
    base = contractor.hourly_rate * contractor.hours
    return calculate_payment(base)
```

### 8.2 긴 함수 (Long Method)

**나쁜 예:**


```python
def process_order(order):
    # 100줄 이상의 코드...
    # 검증, 계산, 저장, 이메일 발송 등 모든 것이 한 함수에
    pass
```

**좋은 예:**


```python
def process_order(order):
    validate_order(order)
    total = calculate_order_total(order)
    payment = process_payment(order, total)
    shipment = create_shipment(order)
    send_confirmation_email(order, payment, shipment)
    return payment
```

### 8.3 거대한 클래스 (Large Class)

**나쁜 예:**


```python
class User:
    def __init__(self):
        # 50개 이상의 필드
        pass
    
    def login(self):
        pass
    
    def logout(self):
        pass
    
    def update_profile(self):
        pass
    
    def change_password(self):
        pass
    
    def add_to_cart(self):
        pass
    
    def checkout(self):
        pass
    
    def add_payment_method(self):
        pass
    
    def send_email(self):
        pass
    
    # ... 50개 이상의 메서드
```

**좋은 예:**


```python
class User:
    def __init__(self, auth_service, profile_service):
        self.id = None
        self.username = None
        self.email = None
        self._auth_service = auth_service
        self._profile_service = profile_service

class AuthenticationService:
    def login(self, user, password):
        pass
    
    def logout(self, user):
        pass
    
    def change_password(self, user, new_password):
        pass

class ProfileService:
    def update_profile(self, user, profile_data):
        pass
    
    def get_profile(self, user_id):
        pass

class ShoppingCart:
    def add_item(self, item):
        pass
    
    def remove_item(self, item):
        pass
    
    def checkout(self):
        pass

class PaymentService:
    def add_payment_method(self, user, payment_method):
        pass
    
    def process_payment(self, order, payment_method):
        pass
```

### 8.4 긴 매개변수 목록 (Long Parameter List)

**나쁜 예:**


```python
def create_account(
    username,
    password,
    email,
    first_name,
    last_name,
    phone,
    address,
    city,
    country,
    postal_code,
    birth_date,
    gender
):
    pass
```

**좋은 예:**


```python
class UserRegistration:
    def __init__(self):
        self.username = None
        self.password = None
        self.email = None
        self.personal_info = PersonalInfo()
        self.contact_info = ContactInfo()

class PersonalInfo:
    def __init__(self):
        self.first_name = None
        self.last_name = None
        self.birth_date = None
        self.gender = None

class ContactInfo:
    def __init__(self):
        self.phone = None
        self.address = Address()

class Address:
    def __init__(self):
        self.street = None
        self.city = None
        self.country = None
        self.postal_code = None

def create_account(registration):
    pass
```

### 8.5 발산적 변경 (Divergent Change)

**하나의 클래스가 여러 이유로 변경되는 경우**

**나쁜 예:**


```python
class Product:
    def calculate_price(self):
        # 가격 계산 로직 - 가격 정책이 바뀌면 수정
        pass
    
    def save_to_database(self):
        # DB 저장 로직 - DB 스키마가 바뀌면 수정
        pass
    
    def display_html(self):
        # HTML 렌더링 - UI가 바뀌면 수정
        pass
    
    def generate_report(self):
        # 리포트 생성 - 리포트 형식이 바뀌면 수정
        pass
    
    def validate(self):
        # 검증 로직 - 검증 규칙이 바뀌면 수정
        pass
```

**좋은 예:**


```python
class Product:
    def __init__(self, id, name, base_price):
        self.id = id
        self.name = name
        self.base_price = base_price

class PriceCalculator:
    def calculate_price(self, product):
        # 가격 계산 로직만 담당
        pass

class ProductRepository:
    def save(self, product):
        # DB 저장 로직만 담당
        pass
    
    def find_by_id(self, product_id):
        pass

class ProductRenderer:
    def render_html(self, product):
        # HTML 렌더링만 담당
        pass

class ProductReportGenerator:
    def generate(self, products):
        # 리포트 생성만 담당
        pass

class ProductValidator:
    def validate(self, product):
        # 검증만 담당
        pass
```

### 8.6 산탄총 수술 (Shotgun Surgery)

**하나의 변경을 위해 여러 클래스를 수정해야 하는 경우**

**나쁜 예:**


```python
# 사용자 이름 형식을 변경하려면 모든 클래스를 수정해야 함
class UserController:
    def display_user(self, user):
        name = user.first_name + " " + user.last_name
        print(name)

class UserRepository:
    def save(self, user):
        full_name = user.first_name + " " + user.last_name
        db.save(full_name)

class EmailService:
    def send_welcome_email(self, user):
        name = user.first_name + " " + user.last_name
        self.send(f"Welcome {name}")

class ReportGenerator:
    def generate_user_report(self, user):
        name = user.first_name + " " + user.last_name
        return f"Report for {name}"
```

**좋은 예:**


```python
class User:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
    
    def get_full_name(self):
        # 이름 형식이 변경되면 여기만 수정
        return f"{self.first_name} {self.last_name}"

class UserController:
    def display_user(self, user):
        print(user.get_full_name())

class UserRepository:
    def save(self, user):
        db.save(user.get_full_name())

class EmailService:
    def send_welcome_email(self, user):
        self.send(f"Welcome {user.get_full_name()}")

class ReportGenerator:
    def generate_user_report(self, user):
        return f"Report for {user.get_full_name()}"
```

### 8.7 기능 편애 (Feature Envy)

**한 클래스의 메서드가 다른 클래스의 데이터를 더 많이 사용하는 경우**

**나쁜 예:**


```python
class Customer:
    def __init__(self):
        self.name = None
        self.address = None
        self.phone = None

class Invoice:
    def __init__(self, customer):
        self.customer = customer
        self.items = []
    
    def get_customer_info(self):
        # Customer의 데이터를 과도하게 사용
        return (
            f"Name: {self.customer.name}, "
            f"Address: {self.customer.address}, "
            f"Phone: {self.customer.phone}"
        )
    
    def print_customer_details(self):
        # Customer에 대한 작업을 Invoice가 수행
        print(f"Customer: {self.customer.name}")
        print(f"Lives at: {self.customer.address}")
        print(f"Contact: {self.customer.phone}")
```

**좋은 예:**


```python
class Customer:
    def __init__(self, name, address, phone):
        self.name = name
        self.address = address
        self.phone = phone
    
    def get_info(self):
        return f"Name: {self.name}, Address: {self.address}, Phone: {self.phone}"
    
    def print_details(self):
        print(f"Customer: {self.name}")
        print(f"Lives at: {self.address}")
        print(f"Contact: {self.phone}")

class Invoice:
    def __init__(self, customer):
        self.customer = customer
        self.items = []
    
    def print_invoice(self):
        self.customer.print_details()
        self._print_items()
    
    def _print_items(self):
        for item in self.items:
            print(f"{item.name}: {item.price}")
```

### 8.8 데이터 덩어리 (Data Clumps)

**항상 함께 다니는 데이터들**

**나쁜 예:**


```python
def create_user(name, street, city, state, zip_code):
    pass

def update_user_address(user_id, street, city, state, zip_code):
    pass

def validate_address(street, city, state, zip_code):
    pass

def format_address(street, city, state, zip_code):
    return f"{street}, {city}, {state} {zip_code}"
```

**좋은 예:**


```python
class Address:
    def __init__(self, street, city, state, zip_code):
        self.street = street
        self.city = city
        self.state = state
        self.zip_code = zip_code
    
    def validate(self):
        if not self.street or not self.city:
            raise ValueError("Invalid address")
    
    def format(self):
        return f"{self.street}, {self.city}, {self.state} {self.zip_code}"

def create_user(name, address):
    address.validate()
    pass

def update_user_address(user_id, address):
    address.validate()
    pass
```

### 8.9 기본형 집착 (Primitive Obsession)

**작은 객체 대신 기본 타입을 과도하게 사용**

**나쁜 예:**


```python
class Order:
    def __init__(self):
        self.customer_name = ""
        self.customer_email = ""
        self.customer_phone = ""
        
        self.billing_street = ""
        self.billing_city = ""
        self.billing_zip = ""
        
        self.shipping_street = ""
        self.shipping_city = ""
        self.shipping_zip = ""
        
        self.price = 0.0
        self.currency = "USD"
        
        self.status = "pending"  # "pending", "shipped", "delivered"

def validate_email(email):
    # 이메일 검증 로직
    pass

def validate_phone(phone):
    # 전화번호 검증 로직
    pass

def format_currency(amount, currency):
    # 통화 포맷팅
    pass
```

**좋은 예:**


```python
class Email:
    def __init__(self, address):
        self._validate(address)
        self.address = address
    
    def _validate(self, address):
        if '@' not in address:
            raise ValueError("Invalid email")

class PhoneNumber:
    def __init__(self, number):
        self._validate(number)
        self.number = number
    
    def _validate(self, number):
        if not number.isdigit():
            raise ValueError("Invalid phone number")

class Address:
    def __init__(self, street, city, zip_code):
        self.street = street
        self.city = city
        self.zip_code = zip_code

class Money:
    def __init__(self, amount, currency="USD"):
        self.amount = amount
        self.currency = currency
    
    def format(self):
        return f"{self.currency} {self.amount:.2f}"
    
    def add(self, other):
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies")
        return Money(self.amount + other.amount, self.currency)

class OrderStatus:
    PENDING = "pending"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    
    def __init__(self, status):
        if status not in [self.PENDING, self.SHIPPED, self.DELIVERED]:
            raise ValueError("Invalid status")
        self.status = status

class Customer:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = Email(email)
        self.phone = PhoneNumber(phone)

class Order:
    def __init__(self, customer, billing_address, shipping_address):
        self.customer = customer
        self.billing_address = billing_address
        self.shipping_address = shipping_address
        self.price = Money(0)
        self.status = OrderStatus(OrderStatus.PENDING)
```

### 8.10 Switch 문 (Switch Statements)

**나쁜 예:**


```python
def calculate_payment(employee):
    if employee.type == "FULL_TIME":
        return employee.monthly_salary
    elif employee.type == "PART_TIME":
        return employee.hourly_rate * employee.hours
    elif employee.type == "CONTRACTOR":
        return employee.project_rate
    elif employee.type == "INTERN":
        return employee.stipend
    else:
        raise ValueError("Unknown employee type")

def calculate_bonus(employee):
    if employee.type == "FULL_TIME":
        return employee.monthly_salary * 0.1
    elif employee.type == "PART_TIME":
        return employee.hourly_rate * employee.hours * 0.05
    elif employee.type == "CONTRACTOR":
        return 0
    elif employee.type == "INTERN":
        return 0
    else:
        raise ValueError("Unknown employee type")

# 새로운 직원 타입이 추가되면 모든 함수를 수정해야 함
```

**좋은 예 (다형성 사용):**


```python
from abc import ABC, abstractmethod

class Employee(ABC):
    @abstractmethod
    def calculate_payment(self):
        pass
    
    @abstractmethod
    def calculate_bonus(self):
        pass

class FullTimeEmployee(Employee):
    def __init__(self, monthly_salary):
        self.monthly_salary = monthly_salary
    
    def calculate_payment(self):
        return self.monthly_salary
    
    def calculate_bonus(self):
        return self.monthly_salary * 0.1

class PartTimeEmployee(Employee):
    def __init__(self, hourly_rate, hours):
        self.hourly_rate = hourly_rate
        self.hours = hours
    
    def calculate_payment(self):
        return self.hourly_rate * self.hours
    
    def calculate_bonus(self):
        return self.calculate_payment() * 0.05

class Contractor(Employee):
    def __init__(self, project_rate):
        self.project_rate = project_rate
    
    def calculate_payment(self):
        return self.project_rate
    
    def calculate_bonus(self):
        return 0

class Intern(Employee):
    def __init__(self, stipend):
        self.stipend = stipend
    
    def calculate_payment(self):
        return self.stipend
    
    def calculate_bonus(self):
        return 0

# 새로운 직원 타입 추가 시 새 클래스만 생성하면 됨
class Freelancer(Employee):
    def __init__(self, daily_rate, days):
        self.daily_rate = daily_rate
        self.days = days
    
    def calculate_payment(self):
        return self.daily_rate * self.days
    
    def calculate_bonus(self):
        return 0
```

### 8.11 임시 필드 (Temporary Field)

**특정 상황에서만 사용되는 인스턴스 변수**

**나쁜 예:**


```python
class Order:
    def __init__(self):
        self.items = []
        self.customer = None
        # 이 필드들은 calculate_total 메서드에서만 사용됨
        self._subtotal = 0
        self._tax = 0
        self._discount = 0
    
    def calculate_total(self):
        self._subtotal = sum(item.price for item in self.items)
        self._tax = self._subtotal * 0.1
        self._discount = self._calculate_discount()
        return self._subtotal + self._tax - self._discount
    
    def _calculate_discount(self):
        if self._subtotal > 100:
            return self._subtotal * 0.1
        return 0
```

**좋은 예:**


```python
class Order:
    def __init__(self):
        self.items = []
        self.customer = None
    
    def calculate_total(self):
        calculator = OrderTotalCalculator(self.items)
        return calculator.calculate()

class OrderTotalCalculator:
    def __init__(self, items):
        self.items = items
    
    def calculate(self):
        subtotal = self._calculate_subtotal()
        tax = self._calculate_tax(subtotal)
        discount = self._calculate_discount(subtotal)
        return subtotal + tax - discount
    
    def _calculate_subtotal(self):
        return sum(item.price for item in self.items)
    
    def _calculate_tax(self, subtotal):
        return subtotal * 0.1
    
    def _calculate_discount(self, subtotal):
        if subtotal > 100:
            return subtotal * 0.1
        return 0
```

### 8.12 메시지 체인 (Message Chains)

**나쁜 예:**


```python
# 여러 단계를 거쳐 접근
street = order.get_customer().get_address().get_street()
discount = user.get_account().get_membership().get_discount_rate()
```

**좋은 예:**


```python
class Order:
    def get_customer_street(self):
        return self.customer.get_street()

class User:
    def get_membership_discount(self):
        return self.account.membership.discount_rate

# 사용
street = order.get_customer_street()
discount = user.get_membership_discount()
```

### 8.13 중개자 (Middle Man)

**위임만 하는 클래스**

**나쁨 예:**


```python
class Department:
    def __init__(self, manager):
        self._manager = manager
    
    def get_manager_name(self):
        return self._manager.name
    
    def get_manager_email(self):
        return self._manager.email
    
    def get_manager_phone(self):
        return self._manager.phone
    
    def get_manager_department(self):
        return self._manager.department
    
    # 모든 것을 위임만 함
```

**좋은 예:**


```python
class Department:
    def __init__(self, manager):
        self.manager = manager  # 직접 접근하도록

# 사용
dept = Department(manager)
name = dept.manager.name
email = dept.manager.email
```

### 8.14 부적절한 친밀 (Inappropriate Intimacy)

**클래스들이 서로의 private 부분에 과도하게 접근**

**나쁜 예:**


```python
class Account:
    def __init__(self):
        self._balance = 0
        self._transactions = []
    
    def get_balance(self):
        return self._balance
    
    def get_transactions(self):
        return self._transactions

class AccountReport:
    def generate(self, account):
        # Account의 내부 구조에 과도하게 의존
        balance = account._balance  # private 필드 직접 접근
        transactions = account._transactions  # private 필드 직접 접근
        
        report = f"Balance: {balance}\n"
        for trans in transactions:
            report += f"{trans._date} - {trans._amount}\n"  # 또 private 접근
        
        return report
```

**좋은 예:**


```python
class Account:
    def __init__(self):
        self._balance = 0
        self._transactions = []
    
    def get_balance(self):
        return self._balance
    
    def get_transaction_summary(self):
        return [
            {"date": t.date, "amount": t.amount} 
            for t in self._transactions
        ]

class AccountReport:
    def generate(self, account):
        balance = account.get_balance()
        transactions = account.get_transaction_summary()
        
        report = f"Balance: {balance}\n"
        for trans in transactions:
            report += f"{trans['date']} - {trans['amount']}\n"
        
        return report
```

### 8.15 상속 거부 (Refused Bequest)

**서브클래스가 부모의 메서드나 데이터를 사용하지 않는 경우**

**나쁜 예:**


```python
class Bird:
    def fly(self):
        return "I can fly"
    
    def eat(self):
        return "I can eat"

class Penguin(Bird):
    def fly(self):
        # 펭귄은 날 수 없는데 억지로 상속
        raise NotImplementedError("Penguins can't fly")
```

**좋은 예:**


```python
class Bird:
    def eat(self):
        return "I can eat"

class FlyingBird(Bird):
    def fly(self):
        return "I can fly"

class Penguin(Bird):
    def swim(self):
        return "I can swim"

class Eagle(FlyingBird):
    pass
```

### 8.16 주석 (Comments as Code Smell)

**나쁜 예:**


```python
def process(data):
    # 데이터 검증
    if not data:
        return None
    
    # 데이터 변환
    result = []
    for item in data:
        # 음수 값 필터링
        if item >= 0:
            # 10 곱하기
            result.append(item * 10)
    
    # 정렬
    result.sort()
    
    return result
```

**좋은 예:**


```python
def process(data):
    if not is_valid_data(data):
        return None
    
    transformed = transform_data(data)
    filtered = filter_positive_values(transformed)
    return sort_values(filtered)

def is_valid_data(data):
    return data is not None and len(data) > 0

def transform_data(data):
    return [item * 10 for item in data]

def filter_positive_values(data):
    return [item for item in data if item >= 0]

def sort_values(data):
    return sorted(data)
```

## 9. 경계 (Boundaries)

### 9.1 외부 코드 사용하기

**나쁜 예:**


```python
# 외부 라이브러리를 직접 사용 - 앱 전체에 의존성 분산
import external_payment_library

class OrderService:
    def process_payment(self, order):
        payment = external_payment_library.Payment()
        payment.set_amount(order.total)
        payment.set_currency("USD")
        result = payment.process()
        return result

class SubscriptionService:
    def charge_subscription(self, user):
        payment = external_payment_library.Payment()
        payment.set_amount(user.subscription_fee)
        payment.set_currency("USD")
        result = payment.process()
        return result
```

**좋은 예:**


```python
# 외부 라이브러리를 감싸는 어댑터 생성
import external_payment_library

class PaymentGateway:
    """외부 결제 라이브러리를 감싸는 어댑터"""
    
    def __init__(self):
        self._gateway = external_payment_library.Payment()
    
    def charge(self, amount, currency="USD"):
        self._gateway.set_amount(amount)
        self._gateway.set_currency(currency)
        result = self._gateway.process()
        
        # 외부 라이브러리의 응답을 우리 형식으로 변환
        return PaymentResult(
            success=result.status == "success",
            transaction_id=result.id,
            message=result.message
        )

class PaymentResult:
    def __init__(self, success, transaction_id, message):
        self.success = success
        self.transaction_id = transaction_id
        self.message = message

class OrderService:
    def __init__(self, payment_gateway):
        self.payment_gateway = payment_gateway
    
    def process_payment(self, order):
        return self.payment_gateway.charge(order.total)

class SubscriptionService:
    def __init__(self, payment_gateway):
        self.payment_gateway = payment_gateway
    
    def charge_subscription(self, user):
        return self.payment_gateway.charge(user.subscription_fee)
```

### 9.2 경계 학습 테스트

**외부 API를 학습하기 위한 테스트 작성**


```python
import pytest

class TestExternalPaymentLibrary:
    """외부 라이브러리의 동작을 이해하기 위한 학습 테스트"""
    
    def test_basic_payment_flow(self):
        # 기본 결제 흐름 이해
        payment = external_payment_library.Payment()
        payment.set_amount(100)
        payment.set_currency("USD")
        result = payment.process()
        
        assert result.status == "success"
        assert result.id is not None
    
    def test_invalid_currency(self):
        # 잘못된 통화 코드 처리 방식 확인
        payment = external_payment_library.Payment()
        payment.set_amount(100)
        payment.set_currency("INVALID")
        
        with pytest.raises(external_payment_library.InvalidCurrencyError):
            payment.process()
    
    def test_zero_amount(self):
        # 0원 결제 처리 방식 확인
        payment = external_payment_library.Payment()
        payment.set_amount(0)
        result = payment.process()
        
        assert result.status == "rejected"
```

### 9.3 아직 존재하지 않는 코드 사용하기

**나쁜 예:**


```python
class WeatherDisplay:
    def update(self):
        # 아직 구현되지 않은 WeatherAPI를 직접 호출
        # API 팀이 완료될 때까지 대기...
        pass
```

**좋은 예:**


```python
# 인터페이스 먼저 정의
from abc import ABC, abstractmethod

class WeatherDataProvider(ABC):
    @abstractmethod
    def get_temperature(self):
        pass
    
    @abstractmethod
    def get_humidity(self):
        pass
    
    @abstractmethod
    def get_wind_speed(self):
        pass

class WeatherDisplay:
    def __init__(self, weather_provider: WeatherDataProvider):
        self.weather_provider = weather_provider
    
    def update(self):
        temp = self.weather_provider.get_temperature()
        humidity = self.weather_provider.get_humidity()
        wind = self.weather_provider.get_wind_speed()
        
        print(f"Temperature: {temp}°C")
        print(f"Humidity: {humidity}%")
        print(f"Wind: {wind} km/h")

# 테스트용 가짜 구현
class FakeWeatherProvider(WeatherDataProvider):
    def get_temperature(self):
        return 25
    
    def get_humidity(self):
        return 60
    
    def get_wind_speed(self):
        return 15

# 실제 API가 준비되면 구현
class RealWeatherAPI(WeatherDataProvider):
    def __init__(self, api_key):
        self.api = ExternalWeatherAPI(api_key)
    
    def get_temperature(self):
        return self.api.fetch_data()['temp']
    
    def get_humidity(self):
        return self.api.fetch_data()['humidity']
    
    def get_wind_speed(self):
        return self.api.fetch_data()['wind']

# 사용
display = WeatherDisplay(FakeWeatherProvider())
display.update()

# 나중에 실제 API로 교체
display = WeatherDisplay(RealWeatherAPI("api-key-123"))
display.update()
```

## 10. 단위 테스트 (Unit Tests)

### 10.1 TDD의 세 가지 법칙

1. **실패하는 단위 테스트를 작성하기 전에는 프로덕션 코드를 작성하지 않는다**
2. **컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다**
3. **현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다**

### 10.2 깨끗한 테스트 코드

**나쁜 예:**


```python
def test_add_user():
    db = Database()
    db.connect("localhost", "testdb", "user", "pass")
    users_before = db.query("SELECT COUNT(*) FROM users")[0][0]
    
    u = User()
    u.name = "John"
    u.email = "john@example.com"
    u.age = 30
    db.insert("users", {"name": u.name, "email": u.email, "age": u.age})
    
    users_after = db.query("SELECT COUNT(*) FROM users")[0][0]
    assert users_after == users_before + 1
    
    result = db.query("SELECT * FROM users WHERE email='john@example.com'")
    assert result[0][1] == "John"
    assert result[0][2] == "john@example.com"
    
    db.close()
```

**좋은 예:**


```python
def test_add_user():
    # Given (준비)
    user = create_test_user(name="John", email="john@example.com")
    
    # When (실행)
    user_repository.save(user)
    
    # Then (검증)
    saved_user = user_repository.find_by_email("john@example.com")
    assert saved_user.name == "John"
    assert saved_user.email == "john@example.com"

def create_test_user(**kwargs):
    defaults = {"name": "Test User", "email": "test@example.com", "age": 25}
    defaults.update(kwargs)
    return User(**defaults)
```

### 10.3 테스트당 하나의 개념

**나쁜 예:**


```python
def test_user_operations():
    # 사용자 생성 테스트
    user = User("John", "john@example.com")
    assert user.name == "John"
    
    # 사용자 업데이트 테스트
    user.update_email("newemail@example.com")
    assert user.email == "newemail@example.com"
    
    # 사용자 삭제 테스트
    user_id = user.id
    user.delete()
    assert user_repository.find(user_id) is None
```

**좋은 예:**


```python
def test_create_user():
    user = User("John", "john@example.com")
    assert user.name == "John"
    assert user.email == "john@example.com"

def test_update_user_email():
    user = create_test_user()
    
    user.update_email("newemail@example.com")
    
    assert user.email == "newemail@example.com"

def test_delete_user():
    user = create_test_user()
    user_id = user.id
    
    user.delete()
    
    assert user_repository.find(user_id) is None
```

### 10.4 F.I.R.S.T 원칙

**Fast (빠르게):**
```python
# 나쁜 예: 느린 테스트
def test_user_registration():
    time.sleep(5)  # 외부 API 호출 대기
    result = external_api.register_user("test@example.com")
    assert result.success

# 좋은 예: 빠른 테스트
def test_user_registration():
    mock_api = Mock()
    mock_api.register_user.return_value = RegistrationResult(success=True)
    
    result = mock_api.register_user("test@example.com")
    assert result.success
```

**Independent (독립적):**
```python
# 나쁜 예: 테스트 간 의존성
def test_create_user():
    global test_user
    test_user = User("John")
    user_repository.save(test_user)

def test_update_user():
    # test_create_user가 먼저 실행되어야 함
    test_user.name = "Jane"
    user_repository.update(test_user)

# 좋은 예: 각 테스트가 독립적
def test_create_user():
    user = User("John")
    user_repository.save(user)
    assert user.id is not None

def test_update_user():
    user = create_test_user(name="John")
    user_repository.save(user)
    
    user.name = "Jane"
    user_repository.update(user)
    updated = user_repository.find(user.id) assert updated.name == "Jane"
```

**Repeatable (반복 가능):**
```python
# 나쁜 예: 환경에 의존
def test_current_time():
    assert get_current_hour() == 14  # 오후 2시에만 통과

# 좋은 예: 시간을 주입
def test_current_time():
    mock_clock = Mock()
    mock_clock.now.return_value = datetime(2024, 1, 1, 14, 0, 0)
    
    time_service = TimeService(mock_clock)
    assert time_service.get_current_hour() == 14
```

**Self-Validating (자가 검증):**
```python
# 나쁜 예: 수동 확인 필요
def test_generate_report():
    report = generate_report()
    print(report)  # 사람이 직접 확인해야 함

# 좋은 예: 자동 검증
def test_generate_report():
    report = generate_report()
    assert "Total Sales" in report
    assert report.contains_data_for_last_month()
    assert report.total > 0
```

**Timely (적시에):**
```python
# 프로덕션 코드 작성 전에 테스트 먼저 작성
def test_calculate_discount():
    # 테스트 먼저 작성 (아직 구현 안됨)
    calculator = DiscountCalculator()
    discount = calculator.calculate(price=100, customer_type="VIP")
    assert discount == 20

# 그 다음 구현
class DiscountCalculator:
    def calculate(self, price, customer_type):
        if customer_type == "VIP":
            return price * 0.2
        return 0
```

## 11. 클래스 (Classes)

### 11.1 클래스는 작아야 한다

**클래스 크기는 책임의 개수로 측정합니다.**

**나쁜 예:**
```python
class UserManager:
    """사용자와 관련된 모든 것을 처리"""
    
    def create_user(self, user_data):
        pass
    
    def update_user(self, user_id, user_data):
        pass
    
    def delete_user(self, user_id):
        pass
    
    def authenticate(self, username, password):
        pass
    
    def reset_password(self, email):
        pass
    
    def send_welcome_email(self, user):
        pass
    
    def generate_user_report(self, user_id):
        pass
    
    def export_users_to_csv(self):
        pass
    
    def import_users_from_csv(self, file_path):
        pass
    
    def calculate_user_statistics(self):
        pass
    
    def backup_user_data(self):
        pass
```

**좋은 예:**
```python
class UserRepository:
    """사용자 데이터 저장/조회"""
    
    def save(self, user):
        pass
    
    def find_by_id(self, user_id):
        pass
    
    def delete(self, user_id):
        pass

class AuthenticationService:
    """인증 관련 로직"""
    
    def authenticate(self, username, password):
        pass
    
    def reset_password(self, email):
        pass

class UserNotificationService:
    """사용자 알림"""
    
    def send_welcome_email(self, user):
        pass
    
    def send_password_reset_email(self, user):
        pass

class UserReportGenerator:
    """사용자 리포트 생성"""
    
    def generate_user_report(self, user_id):
        pass
    
    def calculate_statistics(self):
        pass

class UserDataExporter:
    """사용자 데이터 내보내기/가져오기"""
    
    def export_to_csv(self):
        pass
    
    def import_from_csv(self, file_path):
        pass
```

### 11.2 단일 책임 원칙 (SRP)

**클래스는 변경할 이유가 하나뿐이어야 합니다.**

**나쁜 예:**
```python
class Employee:
    def __init__(self, name, type):
        self.name = name
        self.type = type
    
    def calculate_pay(self):
        # 회계팀이 관리
        if self.type == "FULL_TIME":
            return 5000
        return 3000
    
    def save(self):
        # DBA가 관리
        db.execute("INSERT INTO employees...")
    
    def describe_job(self):
        # HR 팀이 관리
        return f"{self.name} is a {self.type} employee"
```

**좋은 예:**
```python
class Employee:
    def __init__(self, name, type):
        self.name = name
        self.type = type

class PayCalculator:
    def calculate_pay(self, employee):
        if employee.type == "FULL_TIME":
            return 5000
        return 3000

class EmployeeRepository:
    def save(self, employee):
        db.execute("INSERT INTO employees...")

class EmployeeDescriptor:
    def describe(self, employee):
        return f"{employee.name} is a {employee.type} employee"
```

### 11.3 응집도 (Cohesion)

**클래스의 메서드와 변수는 서로 의존하고 연관되어야 합니다.**

**낮은 응집도 (나쁜 예):**
```python
class UserDashboard:
    def __init__(self):
        # 사용자 관련
        self.username = None
        self.email = None
        
        # 제품 관련
        self.products = []
        self.categories = []
        
        # 주문 관련
        self.orders = []
        self.shipping_address = None
    
    def get_user_info(self):
        return f"{self.username} - {self.email}"
    
    def add_product(self, product):
        self.products.append(product)
    
    def place_order(self, items):
        order = Order(items, self.shipping_address)
        self.orders.append(order)
```

**높은 응집도 (좋은 예):**
```python
class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email
    
    def get_info(self):
        return f"{self.username} - {self.email}"

class ProductCatalog:
    def __init__(self):
        self.products = []
        self.categories = []
    
    def add_product(self, product):
        self.products.append(product)
    
    def get_products_by_category(self, category):
        return [p for p in self.products if p.category == category]

class OrderManager:
    def __init__(self):
        self.orders = []
    
    def place_order(self, user, items, shipping_address):
        order = Order(user, items, shipping_address)
        self.orders.append(order)
        return order
```

### 11.4 변경으로부터 격리 (의존성 역전)

**나쁜 예:**
```python
class OrderProcessor:
    def __init__(self):
        # 구체적인 클래스에 직접 의존
        self.payment = CreditCardPayment()
        self.shipping = FedExShipping()
        self.notification = EmailNotification()
    
    def process(self, order):
        self.payment.charge(order.total)
        self.shipping.ship(order)
        self.notification.send(order.customer.email)
```

**좋은 예:**
```python
from abc import ABC, abstractmethod

# 추상화에 의존
class PaymentMethod(ABC):
    @abstractmethod
    def charge(self, amount):
        pass

class ShippingService(ABC):
    @abstractmethod
    def ship(self, order):
        pass

class NotificationService(ABC):
    @abstractmethod
    def send(self, recipient, message):
        pass

# 구체적인 구현
class CreditCardPayment(PaymentMethod):
    def charge(self, amount):
        print(f"Charging ${amount} to credit card")

class FedExShipping(ShippingService):
    def ship(self, order):
        print(f"Shipping order via FedEx")

class EmailNotification(NotificationService):
    def send(self, recipient, message):
        print(f"Sending email to {recipient}")

# 의존성 주입
class OrderProcessor:
    def __init__(
        self, 
        payment: PaymentMethod,
        shipping: ShippingService,
        notification: NotificationService
    ):
        self.payment = payment
        self.shipping = shipping
        self.notification = notification
    
    def process(self, order):
        self.payment.charge(order.total)
        self.shipping.ship(order)
        self.notification.send(
            order.customer.email,
            f"Order {order.id} confirmed"
        )

# 사용
processor = OrderProcessor(
    CreditCardPayment(),
    FedExShipping(),
    EmailNotification()
)

# 쉽게 다른 구현으로 교체 가능
processor = OrderProcessor(
    PayPalPayment(),
    UPSShipping(),
    SMSNotification()
)
```

## 12. SOLID 원칙

### 12.1 단일 책임 원칙 (Single Responsibility Principle)

**클래스는 하나의 책임만 가져야 합니다.**

**나쁜 예:**
```python
class Report:
    def __init__(self, data):
        self.data = data
    
    def generate(self):
        # 리포트 생성 로직
        pass
    
    def print(self):
        # 프린터로 출력
        pass
    
    def save_to_file(self, filename):
        # 파일로 저장
        pass
    
    def send_email(self, recipient):
        # 이메일 전송
        pass
```

**좋은 예:**
```python
class Report:
    def __init__(self, data):
        self.data = data
    
    def generate(self):
        # 리포트 생성만 담당
        pass

class ReportPrinter:
    def print(self, report):
        pass

class ReportStorage:
    def save(self, report, filename):
        pass

class ReportEmailer:
    def send(self, report, recipient):
        pass
```

### 12.2 개방-폐쇄 원칙 (Open-Closed Principle)

**확장에는 열려 있고, 수정에는 닫혀 있어야 합니다.**

**나쁜 예:**
```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

class Circle:
    def __init__(self, radius):
        self.radius = radius

class AreaCalculator:
    def calculate(self, shapes):
        total = 0
        for shape in shapes:
            if isinstance(shape, Rectangle):
                total += shape.width * shape.height
            elif isinstance(shape, Circle):
                total += 3.14 * shape.radius ** 2
            # 새로운 도형이 추가될 때마다 이 메서드를 수정해야 함
        return total
```

**좋은 예:**
```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height

class AreaCalculator:
    def calculate(self, shapes):
        # 새로운 도형이 추가되어도 수정 불필요
        return sum(shape.area() for shape in shapes)
```

### 12.3 리스코프 치환 원칙 (Liskov Substitution Principle)

**하위 타입은 상위 타입을 대체할 수 있어야 합니다.**

**나쁜 예:**
```python
class Bird:
    def fly(self):
        return "I can fly"

class Duck(Bird):
    def fly(self):
        return "Duck flying"

class Ostrich(Bird):
    def fly(self):
        # 타조는 날 수 없음 - LSP 위반
        raise Exception("Can't fly")

def make_bird_fly(bird: Bird):
    # Ostrich를 전달하면 예외 발생
    return bird.fly()
```

**좋은 예:**
```python
class Bird:
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        return self.fly()
    
    def fly(self):
        pass

class Duck(FlyingBird):
    def fly(self):
        return "Duck flying"

class Ostrich(Bird):
    def move(self):
        return self.run()
    
    def run(self):
        return "Ostrich running"

def make_bird_move(bird: Bird):
    # 모든 Bird 타입에 대해 안전하게 동작
    return bird.move()
```

### 12.4 인터페이스 분리 원칙 (Interface Segregation Principle)

**클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안 됩니다.**

**나쁜 예:**
```python
class Worker(ABC):
    @abstractmethod
    def work(self):
        pass
    
    @abstractmethod
    def eat(self):
        pass
    
    @abstractmethod
    def sleep(self):
        pass

class Human(Worker):
    def work(self):
        return "Working"
    
    def eat(self):
        return "Eating"
    
    def sleep(self):
        return "Sleeping"

class Robot(Worker):
    def work(self):
        return "Working"
    
    def eat(self):
        # 로봇은 먹지 않음 - 불필요한 메서드 구현
        pass
    
    def sleep(self):
        # 로봇은 자지 않음 - 불필요한 메서드 구현
        pass
```

**좋은 예:**
```python
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Sleepable(ABC):
    @abstractmethod
    def sleep(self):
        pass

class Human(Workable, Eatable, Sleepable):
    def work(self):
        return "Working"
    
    def eat(self):
        return "Eating"
    
    def sleep(self):
        return "Sleeping"

class Robot(Workable):
    def work(self):
        return "Working"
    # eat, sleep 구현 불필요
```

### 12.5 의존성 역전 원칙 (Dependency Inversion Principle)

**고수준 모듈은 저수준 모듈에 의존하면 안 됩니다. 둘 다 추상화에 의존해야 합니다.**

**나쁜 예:**
```python
class MySQLDatabase:
    def save(self, data):
        print("Saving to MySQL")

class UserService:
    def __init__(self):
        # 구체적인 구현에 직접 의존
        self.db = MySQLDatabase()
    
    def save_user(self, user):
        self.db.save(user)
```

**좋은 예:**
```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print("Saving to MySQL")

class PostgreSQLDatabase(Database):
    def save(self, data):
        print("Saving to PostgreSQL")

class MongoDatabase(Database):
    def save(self, data):
        print("Saving to MongoDB")

class UserService:
    def __init__(self, database: Database):
        # 추상화에 의존
        self.db = database
    
    def save_user(self, user):
        self.db.save(user)

# 사용
mysql_service = UserService(MySQLDatabase())
postgres_service = UserService(PostgreSQLDatabase())
mongo_service = UserService(MongoDatabase())
```

## 13. 리팩토링 실전 예제

### 실전 예제: 전자상거래 주문 시스템

**리팩토링 전 (나쁜 코드):**
```python
class OrderHandler:
    def process_order(self, customer_id, items, card_number, cvv, address):
        # 고객 정보 조회
        c = db.query(f"SELECT * FROM customers WHERE id={customer_id}")
        if not c:
            return {"error": "Customer not found"}
        
        # 재고 확인
        for i in items:
            s = db.query(f"SELECT stock FROM products WHERE id={i['id']}")
            if s[0][0] < i['qty']:
                return {"error": f"Not enough stock for {i['id']}"}
        
        # 가격 계산
        t = 0
        for i in items:
            p = db.query(f"SELECT price FROM products WHERE id={i['id']}")
            t += p[0][0] * i['qty']
        
        # 할인 적용
        if c[0][3] == "gold":
            t = t * 0.9
        elif c[0][3] == "silver":
            t = t * 0.95
        
        # 배송비
        if t < 50:
            t += 10
        
        # 결제 처리
        if not self.charge_card(card_number, cvv, t):
            return {"error": "Payment failed"}
        
        # 주문 생성
        order_id = db.insert(f"INSERT INTO orders (customer_id, total, status) VALUES ({customer_id}, {t}, 'pending')")
        
        # 주문 상품 저장
        for i in items:
            db.insert(f"INSERT INTO order_items (order_id, product_id, quantity) VALUES ({order_id}, {i['id']}, {i['qty']})")
        
        # 재고 차감
        for i in items:
            db.update(f"UPDATE products SET stock=stock-{i['qty']} WHERE id={i['id']}")
        
        # 이메일 발송
        self.send_email(c[0][2], f"Your order {order_id} has been placed. Total: ${t}")
        
        # 배송 정보 생성
        db.insert(f"INSERT INTO shipments (order_id, address) VALUES ({order_id}, '{address}')")
        
        return {"success": True, "order_id": order_id, "total": t}
    
    def charge_card(self, number, cvv, amount):
        # 결제 로직
        return True
    
    def send_email(self, email, message):
        # 이메일 발송
        pass
```

**리팩토링 후 (클린 코드):**
```python
from dataclasses import dataclass
from decimal import Decimal
from typing import List
from abc import ABC, abstractmethod

# 1. 도메인 모델 정의
@dataclass
class Customer:
    id: int
    name: str
    email: str
    membership_level: str
    
    def get_discount_rate(self) -> Decimal:
        discount_rates = {
            "gold": Decimal("0.10"),
            "silver": Decimal("0.05"),
            "bronze": Decimal("0.00")
        }
        return discount_rates.get(self.membership_level, Decimal("0.00"))

@dataclass
class Product:
    id: int
    name: str
    price: Decimal
    stock: int
    
    def has_sufficient_stock(self, quantity: int) -> bool:
        return self.stock >= quantity

@dataclass
class OrderItem:
    product: Product
    quantity: int
    
    def get_subtotal(self) -> Decimal:
        return self.product.price * self.quantity

@dataclass
class Order:
    id: int
    customer: Customer
    items: List[OrderItem]
    shipping_address: str
    total: Decimal
    status: str

# 2. 리포지토리 패턴
class CustomerRepository:
    def find_by_id(self, customer_id: int) -> Customer:
        result = db.query(
            "SELECT id, name, email, membership_level FROM customers WHERE id = ?",
            (customer_id,)
        )
        if not result:
            raise CustomerNotFoundException(customer_id)
        return Customer(*result[0])

class ProductRepository:
    def find_by_id(self, product_id: int) -> Product:
        result = db.query(
            "SELECT id, name, price, stock FROM products WHERE id = ?",
            (product_id,)
        )
        if not result:
            raise ProductNotFoundException(product_id)
        return Product(*result[0])
    
    def update_stock(self, product_id: int, quantity: int):
        db.execute(
            "UPDATE products SET stock = stock - ? WHERE id = ?",
            (quantity, product_id)
        )

class OrderRepository:
    def save(self, order: Order) -> int:
        order_id = db.insert(
            "INSERT INTO orders (customer_id, total, status) VALUES (?, ?, ?)",
            (order.customer.id, order.total, order.status)
        )
        
        for item in order.items:
            db.insert(
                "INSERT INTO order_items (order_id, product_id, quantity) VALUES (?, ?, ?)",
                (order_id, item.product.id, item.quantity)
            )
        
        return order_id

# 3. 서비스 계층
class InventoryService:
    def __init__(self, product_repository: ProductRepository):
        self.product_repository = product_repository
    
    def validate_stock(self, items: List[dict]):
        for item_data in items:
            product = self.product_repository.find_by_id(item_data['id'])
            if not product.has_sufficient_stock(item_data['quantity']):
                raise InsufficientStockException(product.name)
    
    def reduce_stock(self, items: List[OrderItem]):
        for item in items:
            self.product_repository.update_stock(item.product.id, item.quantity)

class PricingService:
    FREE_SHIPPING_THRESHOLD = Decimal("50.00")
    SHIPPING_COST = Decimal("10.00")
    
    def calculate_order_total(self, customer: Customer, items: List[OrderItem]) -> Decimal:
        subtotal = self._calculate_subtotal(items)
        discounted_total = self._apply_discount(customer, subtotal)
        final_total = self._add_shipping(discounted_total)
        return final_total
    
    def _calculate_subtotal(self, items: List[OrderItem]) -> Decimal:
        return sum(item.get_subtotal() for item in items)
    
    def _apply_discount(self, customer: Customer, subtotal: Decimal) -> Decimal:
        discount_rate = customer.get_discount_rate()
        return subtotal * (Decimal("1.00") - discount_rate)
    
    def _add_shipping(self, total: Decimal) -> Decimal:
        if total < self.FREE_SHIPPING_THRESHOLD:
            return total + self.SHIPPING_COST
        return total

class PaymentService(ABC):
    @abstractmethod
    def process_payment(self, card_number: str, cvv: str, amount: Decimal) -> bool:
        pass

class CreditCardPaymentService(PaymentService):
    def process_payment(self, card_number: str, cvv: str, amount: Decimal) -> bool:
        # 실제 결제 처리 로직
        return True

class NotificationService:
    def send_order_confirmation(self, customer: Customer, order: Order):
        message = self._create_confirmation_message(order)
        self._send_email(customer.email, message)
    
    def _create_confirmation_message(self, order: Order) -> str:
        return f"Your order {order.id} has been placed. Total: ${order.total}"
    
    def _send_email(self, email: str, message: str):
        # 이메일 발송 로직
        pass

class ShippingService:
    def create_shipment(self, order: Order):
        db.insert(
            "INSERT INTO shipments (order_id, address) VALUES (?, ?)",
            (order.id, order.shipping_address)
        )

# 4. 주문 처리 파사드
class OrderProcessingService:
    def __init__(
        self,
        customer_repository: CustomerRepository,
        product_repository: ProductRepository,
        order_repository: OrderRepository,
        inventory_service: InventoryService,
        pricing_service: PricingService,
        payment_service: PaymentService,
        notification_service: NotificationService,
        shipping_service: ShippingService
    ):
        self.customer_repository = customer_repository
        self.product_repository = product_repository
        self.order_repository = order_repository
        self.inventory_service = inventory_service
        self.pricing_service = pricing_service
        self.payment_service = payment_service
        self.notification_service = notification_service
        self.shipping_service = shipping_service
    
    def process_order(
        self,
        customer_id: int,
        items: List[dict],
        card_number: str,
        cvv: str,
        shipping_address: str
    ) -> dict:
        try:
            # 1. 고객 조회
            customer = self.customer_repository.find_by_id(customer_id)
            
            # 2. 재고 검증
            self.inventory_service.validate_stock(items)
            
            # 3. 주문 아이템 생성
            order_items = self._create_order_items(items)
            
            # 4. 가격 계산
            total = self.pricing_service.calculate_order_total(customer, order_items)
            
            # 5. 결제 처리
            if not self.payment_service.process_payment(card_number, cvv, total):
                raise PaymentFailedException()
            
            # 6. 주문 생성
            order = Order(
                id=None,
                customer=customer,
                items=order_items,
                shipping_address=shipping_address,
                total=total,
                status="pending"
            )
            order_id = self.order_repository.save(order)
            order.id = order_id
            
            # 7. 재고 차감
            self.inventory_service.reduce_stock(order_items)
            
            # 8. 배송 정보 생성
            self.shipping_service.create_shipment(order)
            
            # 9. 확인 이메일 발송
            self.notification_service.send_order_confirmation(customer, order)
            
            return {"success": True, "order_id": order_id, "total": str(total)}
        
        except (CustomerNotFoundException, ProductNotFoundException) as e:
            return {"error": f"Not found: {str(e)}"}
        except InsufficientStockException as e:
            return {"error": f"Insufficient stock: {str(e)}"}
        except PaymentFailedException:
            return {"error": "Payment failed"}
        except Exception as e:
            return {"error": f"Order processing failed: {str(e)}"}
    
    def _create_order_items(self, items: List[dict]) -> List[OrderItem]:
        order_items = []
        for item_data in items:
            product = self.product_repository.find_by_id(item_data['id'])
            order_items.append(OrderItem(product, item_data['quantity']))
        return order_items

# 5. 예외 클래스
class CustomerNotFoundException(Exception):
    pass

class ProductNotFoundException(Exception):
    pass

class InsufficientStockException(Exception):
    pass

class PaymentFailedException(Exception):
    pass

# 6. 사용 예시
def main():
    # 의존성 주입
    customer_repo = CustomerRepository()
    product_repo = ProductRepository()
    order_repo = OrderRepository()
    
    inventory_service = InventoryService(product_repo)
    pricing_service = PricingService()
    payment_service = CreditCardPaymentService()
    notification_service = NotificationService()
    shipping_service = ShippingService()
    
    order_service = OrderProcessingService(
        customer_repo,
        product_repo,
        order_repo,
        inventory_service,
        pricing_service,
        payment_service,
        notification_service,
        shipping_service
    )
    
    # 주문 처리
    result = order_service.process_order(
        customer_id=123,
        items=[
            {"id": 1, "quantity": 2},
            {"id": 2, "quantity": 1}
        ],
        card_number="1234-5678-9012-3456",
        cvv="123",
        shipping_address="123 Main St, City, Country"
    )
    
    print(result)
```

## 14. 클린 코드 체크리스트

### 코드 작성 시 체크리스트

**명명 (Naming)**

-  의도를 명확히 드러내는가?
    
-  오해를 유발할 만한 이름을 피했는가?
    
-  의미 있는 구분이 존재하는가?
    
-  발음하기 쉬운 이름인가?
    
-  검색이 용이한 이름인가?
    
-  클래스/객체는 명사, 함수는 동사로 표현했는가?
    
-  헝가리안 표기법 등 인코딩을 피했는가?
    

---

**함수 (Functions)**

-  하나의 함수가 한 가지 작업만 수행하는가?
    
-  함수 길이가 충분히 짧은가? (가능하면 20줄 이내)
    
-  인수 개수가 적절한가? (0–2개 권장, 최대 3개)
    
-  명령과 조회를 분리했는가?
    
-  부수효과(Side Effect)를 피했는가?
    
-  추상화 수준이 섞여 있지 않은가?
    
-  중복 코드를 제거했는가?
    
-  오류 코드 대신 예외를 사용하는가?
    

---

**주석 (Comments)**

-  코드 자체로 의도가 드러나는가?
    
-  불필요한 주석을 제거했는가?
    
-  오해의 소지가 있는 주석이 없는가?
    
-  주석 처리된 죽은 코드를 제거했는가?
    
-  코드 변경에 따라 주석도 함께 갱신했는가?
    

---

**서식 (Formatting)**

-  일관된 코드 스타일을 유지하고 있는가?
    
-  적절한 줄 길이를 지키고 있는가?
    
-  관련된 코드가 가까이 배치되어 있는가?
    
-  변수를 사용하는 위치에 가깝게 선언했는가?
    
-  프로젝트/팀 컨벤션을 준수했는가?
    
-  파일 크기는 적절한가? (200-500줄)
    
-  개념은 빈 행으로 분리했는가?
    
-  개념은 빈 행으로 분리했는가?
---

**오류 처리 (Error Handling)**

-  필요한 경우가 아니면 Checked Exception을 피하고 있는가?
    
-  오류 메시지에 충분한 컨텍스트를 제공하는가?
    
-  null, 빈값 등 특수 케이스를 처리했는가?
    
-  try-catch-finally를 적절히 사용하고 있는가?
    
-  비즈니스 로직과 오류 처리 로직을 분리했는가?
    

---

**테스트 (Tests)**

-  테스트 하나가 하나의 개념만 검증하는가?
    
-  F.I.R.S.T 원칙을 따르는가?
    
-  경계 조건을 테스트했는가?
    
-  테스트 코드 역시 깨끗하게 유지되는가?
    
-  커버리지보다 의미 있는 테스트를 우선하는가?
    

---

**클래스 설계 (Class Design)**

-  클래스는 단일 책임만 가지는가?
    
-  응집도가 높은가?
    
-  클래스 크기가 과도하게 크지 않은가?
    
-  LSP 등 객체지향 원칙을 위반하지 않았는가?
    
-  상속보다 조합(Composition)을 우선 고려했는가?
    

---

**객체 & 데이터 구조 (OOP / Data Structures)**

-  객체는 동작 중심, 데이터 구조는 값 중심으로 설계했는가?
    
-  DTO, Entity, Domain Model이 명확히 분리되었는가?
    
-  캡슐화를 유지했는가?
    
-  내부 상태를 외부에 그대로 노출하지 않았는가?
    
-  불변 객체를 고려했는가?
    

---

**모듈 & 패키지 구조 (Modules & Packaging)**

-  기능이 아닌 책임 기준으로 패키지를 구성했는가?
    
-  순환 의존성을 제거했는가?
    
-  의존성 방향이 안정적으로 유지되는가?
    
-  모듈 간 결합도를 낮추고 응집도를 높였는가?
    

---

**상태 관리 (State Management)**

-  공유 Mutable state를 최소화했는가?
    
-  상태 변경이 명확하게 드러나는가?
    
-  스레드 안전성(Concurrency)을 고려했는가?
    
-  글로벌 상태 사용을 자제했는가?
    

---

**성능 및 최적화 (Performance)**

-  필요하지 않은 조기 최적화를 피했는가?
    
-  알고리즘/자료 구조가 적절한가?
    
-  비용이 큰 연산(I/O, Reflection, DB Query)을 최소화했는가?
    
-  캐싱 여부를 검토했는가?
    

---

**보안 (Security)**

-  입력값 검증을 수행했는가?
    
-  하드코딩된 비밀 정보가 존재하지 않는가?
    
-  민감 데이터 로깅을 피했는가?
    
-  인증·인가 흐름이 분리되고 명확한가?
    

---

**버전 관리 (Git)**

-  커밋 메시지가 명확한가?
    
-  작은 단위로 커밋했는가?
    
-  불필요한 파일이 들어가지 않았는가?
    
-  PR 단위가 작고 리뷰하기 쉬운가?

## 15. 마무리: 클린 코드를 위한 실천 방법

### 일상적인 실천 방법

**1. 보이스카우트 규칙**


````python
# 코드를 체크아웃할 때보다 조금 더 깨끗하게 만들어라
# 변수명 하나, 함수 하나라도 개선하라

# Before
def calc(x, y):
    return x * y * 0.9

# After (체크인 시)
def calculate_discounted_price(original_price, quantity):
    DISCOUNT_RATE = 0.1
    subtotal = original_price * quantity
    return subtotal * (1 - DISCOUNT_RATE)
```

**2. 레드-그린-리팩터 (TDD)**
```
1. RED: 실패하는 테스트 작성
2. GREEN: 테스트를 통과하는 최소한의 코드 작성
3. REFACTOR: 코드를 정리하고 개선
````

**3. 코드 리뷰 활용**


```python
# 리뷰 시 확인할 사항:
# - 이 코드의 의도를 바로 이해할 수 있는가?
# - 함수명이 하는 일을 정확히 설명하는가?
# - 테스트하기 쉬운 구조인가?
# - 중복은 없는가?
# - SOLID 원칙을 따르는가?
```

**4. 점진적 개선**


```python
# 한 번에 모든 것을 고치려 하지 마라
# 매일 조금씩, 지속적으로 개선하라

# 1주차: 함수명 개선
# 2주차: 긴 함수 분리
# 3주차: 중복 코드 제거
# 4주차: 테스트 추가
# 5주차: 의존성 주입 적용
```

**5. 자동화 도구 활용**


```python
# Linter (예: pylint, flake8)
# 코드 스타일 자동 검사

# Formatter (예: black, autopep8)
# 코드 형식 자동 정리

# Static Analysis (예: mypy, bandit)
# 타입 체크, 보안 취약점 검사
```

### 마지막 조언

**클린 코드는 목적지가 아니라 여정입니다.**

- 완벽한 코드는 없습니다. 계속 개선해 나가세요.
- 처음부터 완벽하게 작성하려 하지 마세요. 먼저 작동하게 만들고, 그 다음 깨끗하게 만드세요.
- 팀과 함께 코딩 컨벤션을 정하고 따르세요.
- 코드 리뷰를 통해 서로 배우세요.
- 리팩토링을 두려워하지 마세요. 테스트가 있다면 안전합니다.
- 레거시 코드를 만나면 비난하지 말고 조금씩 개선하세요.
- 읽기 좋은 코드가 작성하기는 어렵지만, 유지보수는 훨씬 쉽습니다.

**"언제나 코드를 처음 본 사람이 쉽게 이해할 수 있도록 작성하라."**