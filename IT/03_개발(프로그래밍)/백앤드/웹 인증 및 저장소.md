---
title: 웹 인증 및 저장소
date: 2026-01-25
tags:
  - it
  - 개발
  - 백앤드
  - 인증및저장소
---
## 1. HTTP의 Stateless 특성

HTTP 프로토콜은 기본적으로 **무상태(stateless)**. 각 요청은 독립적이며, 서버는 이전 요청을 기억하지 못함.

```
Client → Server: GET /login (요청 1)
Server → Client: 200 OK

Client → Server: GET /profile (요청 2)
Server: "이 사용자가 누구지?" ← 이전 요청을 모름
```

실제 웹 애플리케이션에서는 사용자의 로그인 상태, 장바구니, 설정 등 **상태 유지**가 필수적이므로 이를 보완하는 메커니즘이 필요.

---

## 2. 쿠키 (Cookie)

### 2.1 개념
쿠키는 서버가 사용자의 브라우저에 저장하는 작은 텍스트 데이터. 브라우저는 동일한 서버로 요청할 때마다 자동으로 쿠키를 전송.

### 2.2 동작 원리

```http
# 1. 서버 응답 (쿠키 설정)
HTTP/1.1 200 OK
Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict
Content-Type: text/html

# 2. 클라이언트 요청 (쿠키 자동 전송)
GET /api/user HTTP/1.1
Host: example.com
Cookie: sessionId=abc123
```

### 2.3 쿠키 속성

```javascript
res.cookie('name', 'value', {
  maxAge: 3600000,        // 밀리초 (1시간)
  expires: new Date('2026-12-31'), // 만료 날짜
  domain: '.example.com', // 도메인 (서브도메인 포함)
  path: '/',              // URL 경로
  secure: true,           // HTTPS만
  httpOnly: true,         // JavaScript 접근 불가
  sameSite: 'strict'      // CSRF 방어
});
```

**주요 속성 설명**:

- **Expires / Max-Age**: 쿠키 만료 시간
  - 미설정 시 세션 쿠키 (브라우저 종료 시 삭제)
  
- **Domain**: 쿠키 전송 도메인
  - `.example.com` → 모든 서브도메인 포함
  - `example.com` → 정확히 일치하는 도메인만

- **Path**: 쿠키 전송 경로
  - `/` → 모든 경로
  - `/admin` → /admin 하위 경로만

- **Secure**: HTTPS 연결에서만 전송

- **HttpOnly**: JavaScript로 접근 불가 (XSS 방어)

- **SameSite**: 
  - `Strict` → 같은 사이트 요청만
  - `Lax` → 일부 크로스 사이트 허용 (기본값)
  - `None` → 모든 크로스 사이트 허용 (Secure 필수)

### 2.4 쿠키 사용 예제

```javascript
// Express.js
const express = require('express');
const app = express();

// 쿠키 설정
app.get('/set-cookie', (req, res) => {
  res.cookie('userId', '12345', {
    httpOnly: true,
    secure: true,
    maxAge: 24 * 60 * 60 * 1000 // 24시간
  });
  res.send('Cookie set');
});

// 쿠키 읽기
app.get('/get-cookie', (req, res) => {
  const userId = req.cookies.userId;
  res.send(`User ID: ${userId}`);
});

// 쿠키 삭제
app.get('/clear-cookie', (req, res) => {
  res.clearCookie('userId');
  res.send('Cookie cleared');
});
```

```javascript
// 클라이언트 (JavaScript)
// 일반 쿠키는 document.cookie로 접근 가능
document.cookie = "username=john; max-age=3600; path=/";

// 쿠키 읽기
const cookies = document.cookie.split('; ').reduce((acc, cookie) => {
  const [key, value] = cookie.split('=');
  acc[key] = value;
  return acc;
}, {});

console.log(cookies.username); // "john"

// ⚠️ HttpOnly 쿠키는 JavaScript로 접근 불가
```

### 2.5 장단점

**장점**:
- 서버 메모리 부담 없음
- 자동으로 전송되어 편리
- 만료 시간 설정 가능

**단점**:
- 크기 제한 (4KB)
- 매 요청마다 전송 (네트워크 오버헤드)
- XSS, CSRF 공격 대상

---

## 3. 세션 (Session)

### 3.1 개념
세션은 서버 측에서 사용자 상태를 저장하는 메커니즘. 클라이언트는 세션 ID만 쿠키로 저장하고, 실제 데이터는 서버에 보관.

### 3.2 동작 원리

```
1. 사용자 로그인
   Client → Server: POST /login {username, password}

2. 서버에서 세션 생성
   Server: 
   - 세션 ID 생성: "abc123xyz"
   - 세션 저장소에 데이터 저장:
     {
       sessionId: "abc123xyz",
       userId: 12345,
       username: "john",
       loginTime: "2026-01-25T10:00:00Z"
     }

3. 세션 ID를 쿠키로 전송
   Server → Client: 
   Set-Cookie: sessionId=abc123xyz; HttpOnly; Secure

4. 이후 요청
   Client → Server: 
   Cookie: sessionId=abc123xyz
   
   Server: 
   - 쿠키에서 세션 ID 추출
   - 저장소에서 세션 데이터 조회
   - 사용자 인증 완료
```

### 3.3 세션 구현 예제

```javascript
const express = require('express');
const session = require('express-session');
const RedisStore = require('connect-redis').default;
const { createClient } = require('redis');

const app = express();

// Redis 클라이언트 생성
const redisClient = createClient({
  host: 'localhost',
  port: 6379
});
redisClient.connect();

// 세션 미들웨어 설정
app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: 'your-secret-key-change-this',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24 // 24시간
  }
}));

// 로그인
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  // 사용자 인증 (실제로는 DB 조회)
  const user = await authenticateUser(username, password);
  
  if (user) {
    // 세션에 사용자 정보 저장
    req.session.userId = user.id;
    req.session.username = user.username;
    req.session.role = user.role;
    
    res.json({ success: true, user: { id: user.id, username: user.username } });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});

// 보호된 라우트
app.get('/profile', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  res.json({
    userId: req.session.userId,
    username: req.session.username,
    role: req.session.role
  });
});

// 로그아웃
app.post('/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Logout failed' });
    }
    res.clearCookie('connect.sid'); // 기본 세션 쿠키 이름
    res.json({ message: 'Logged out successfully' });
  });
});
```

### 3.4 세션 저장소 비교

| 저장소 | 속도 | 영구성 | 분산 환경 | 용도 |
|--------|------|--------|-----------|------|
| 메모리 | 매우 빠름 | ❌ | ❌ | 개발/테스트 |
| Redis | 빠름 | ⚠️ | ✅ | 프로덕션 (권장) |
| Memcached | 빠름 | ❌ | ✅ | 캐시 위주 |
| Database | 보통 | ✅ | ✅ | 영구 보관 필요 시 |

**Redis 사용 예제**:
```javascript
// Redis에 세션 저장 시
{
  "sess:abc123xyz": {
    "userId": 12345,
    "username": "john",
    "cookie": {
      "expires": "2026-01-26T10:00:00.000Z"
    }
  }
}

// TTL (Time To Live) 자동 설정
// 24시간 후 자동 삭제
```

### 3.5 장단점

**장점**:
- 민감한 정보를 서버에서 안전하게 관리
- 데이터 크기 제한 없음
- 서버에서 세션 즉시 무효화 가능
- 보안성 높음

**단점**:
- 서버 메모리/저장소 필요
- 분산 환경에서 세션 공유 복잡
- 서버 확장성 제한
- 저장소 장애 시 세션 손실 위험

---

## 4. 토큰 (Token)

### 4.1 JWT (JSON Web Token)

JWT는 self-contained 방식으로 사용자 정보를 안전하게 전송하는 토큰.

**구조**: `Header.Payload.Signature`

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VySWQiOiIxMjM0NSIsInVzZXJuYW1lIjoiam9obiIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE2MjQyNjIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**각 부분 설명**:

1. **Header** (헤더):
```json
{
  "alg": "HS256",  // 서명 알고리즘
  "typ": "JWT"     // 토큰 타입
}
```

2. **Payload** (페이로드):
```json
{
  "userId": "12345",
  "username": "john",
  "role": "admin",
  "iat": 1516239022,  // Issued At (발급 시간)
  "exp": 1516242622   // Expiration (만료 시간)
}
```

3. **Signature** (서명):
```javascript
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

### 4.2 JWT 구현 예제

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET;
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;

// 로그인 - 토큰 발급
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  // 사용자 조회
  const user = await User.findOne({ email });
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // 비밀번호 확인
  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Access Token 생성 (15분)
  const accessToken = jwt.sign(
    { 
      userId: user.id,
      email: user.email,
      role: user.role
    },
    ACCESS_SECRET,
    { expiresIn: '15m' }
  );
  
  // Refresh Token 생성 (7일)
  const refreshToken = jwt.sign(
    { userId: user.id },
    REFRESH_SECRET,
    { expiresIn: '7d' }
  );
  
  // Refresh Token을 DB에 저장
  await RefreshToken.create({
    userId: user.id,
    token: refreshToken,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });
  
  // Refresh Token은 HttpOnly 쿠키로
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000
  });
  
  // Access Token은 응답으로
  res.json({ 
    accessToken,
    user: {
      id: user.id,
      email: user.email,
      role: user.role
    }
  });
});

// 토큰 검증 미들웨어
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, ACCESS_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    if (err.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired' });
    }
    return res.status(403).json({ error: 'Invalid token' });
  }
}

// 보호된 라우트
app.get('/api/profile', authenticateToken, (req, res) => {
  res.json({
    userId: req.user.userId,
    email: req.user.email,
    role: req.user.role
  });
});

// Access Token 재발급
app.post('/refresh', async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  
  if (!refreshToken) {
    return res.status(401).json({ error: 'No refresh token' });
  }
  
  try {
    // Refresh Token 검증
    const decoded = jwt.verify(refreshToken, REFRESH_SECRET);
    
    // DB에서 Refresh Token 확인
    const storedToken = await RefreshToken.findOne({
      userId: decoded.userId,
      token: refreshToken
    });
    
    if (!storedToken) {
      return res.status(403).json({ error: 'Invalid refresh token' });
    }
    
    // 새로운 Access Token 발급
    const accessToken = jwt.sign(
      { userId: decoded.userId },
      ACCESS_SECRET,
      { expiresIn: '15m' }
    );
    
    res.json({ accessToken });
  } catch (err) {
    return res.status(403).json({ error: 'Invalid refresh token' });
  }
});

// 로그아웃
app.post('/logout', authenticateToken, async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  
  // DB에서 Refresh Token 삭제
  await RefreshToken.destroy({
    where: { token: refreshToken }
  });
  
  res.clearCookie('refreshToken');
  res.json({ message: 'Logged out successfully' });
});
```

### 4.3 클라이언트에서 JWT 사용

```javascript
// React 예제
import axios from 'axios';

// Access Token을 메모리에 저장
let accessToken = null;

// Axios 인터셉터 설정
axios.interceptors.request.use(
  (config) => {
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// 응답 인터셉터 - 토큰 만료 시 재발급
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // 401 에러이고 재시도하지 않은 요청인 경우
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Refresh Token으로 새 Access Token 발급
        const { data } = await axios.post('/api/refresh', {}, {
          withCredentials: true // 쿠키 전송
        });
        
        accessToken = data.accessToken;
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        
        return axios(originalRequest);
      } catch (refreshError) {
        // Refresh Token도 만료됨 - 로그인 페이지로
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

// 로그인
async function login(email, password) {
  const { data } = await axios.post('/api/login', { email, password }, {
    withCredentials: true // Refresh Token 쿠키 받기
  });
  
  accessToken = data.accessToken;
  return data.user;
}

// API 호출
async function fetchUserProfile() {
  const { data } = await axios.get('/api/profile');
  return data;
}

// 로그아웃
async function logout() {
  await axios.post('/api/logout', {}, {
    withCredentials: true
  });
  accessToken = null;
  window.location.href = '/login';
}
```

### 4.4 Access Token vs Refresh Token

| 구분 | Access Token | Refresh Token |
|------|--------------|---------------|
| 만료 시간 | 짧음 (15분~1시간) | 김 (7일~30일) |
| 용도 | API 요청 인증 | Access Token 재발급 |
| 저장 위치 | 메모리 (권장) | HttpOnly Cookie |
| 탈취 위험 | 높지만 피해 제한적 | 낮지만 피해 큼 |
| 무효화 | 어려움 | DB에서 관리 가능 |

**전략**:
- Access Token은 메모리에 저장하여 XSS 공격 방어
- Refresh Token은 HttpOnly Cookie로 저장하여 JavaScript 접근 차단
- Access Token 만료 시 자동으로 Refresh Token으로 재발급
- 로그아웃 시 서버에서 Refresh Token 삭제

### 4.5 장단점

**장점**:
- Stateless: 서버가 상태를 저장하지 않아 확장성 우수
- 분산 환경에 적합
- 마이크로서비스 아키텍처에 이상적
- 모바일 앱, 웹, IoT 등 다양한 플랫폼에서 사용 가능
- CORS 문제 해결 용이

**단점**:
- 토큰 크기가 커서 네트워크 오버헤드
- 토큰 탈취 시 만료 전까지 무효화 어려움
- Payload가 Base64 인코딩만 되어 있어 민감 정보 노출 위험
- 매 요청마다 검증 필요

---

## 5. OAuth 2.0 & OpenID Connect

### 5.1 OAuth 2.0 개념

OAuth 2.0은 타사 서비스의 리소스에 접근하기 위한 권한 부여 프레임워크.

**주요 역할**:
- **Resource Owner**: 사용자
- **Client**: 서드파티 애플리케이션
- **Authorization Server**: 인증 서버 (Google, GitHub 등)
- **Resource Server**: 실제 리소스를 가진 서버

### 5.2 Authorization Code Flow

가장 안전한 OAuth 2.0 흐름입니다.

```
1. 사용자가 "Google로 로그인" 클릭
   Client → Authorization Server
   
2. 사용자 인증 및 권한 동의
   Authorization Server → User
   
3. Authorization Code 발급
   Authorization Server → Client
   
4. Access Token 요청
   Client → Authorization Server (Code + Client Secret)
   
5. Access Token 발급
   Authorization Server → Client
   
6. 리소스 요청
   Client → Resource Server (Access Token)
```

### 5.3 구현 예제

```javascript
const express = require('express');
const axios = require('axios');
const app = express();

// Google OAuth 설정
const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
const REDIRECT_URI = 'http://localhost:3000/auth/google/callback';

// 1. Google 로그인 시작
app.get('/auth/google', (req, res) => {
  const authUrl = 'https://accounts.google.com/o/oauth2/v2/auth?' +
    new URLSearchParams({
      client_id: GOOGLE_CLIENT_ID,
      redirect_uri: REDIRECT_URI,
      response_type: 'code',
      scope: 'openid email profile',
      access_type: 'offline', // Refresh Token 받기
      prompt: 'consent'
    });
  
  res.redirect(authUrl);
});

// 2. Google 콜백 처리
app.get('/auth/google/callback', async (req, res) => {
  const { code } = req.query;
  
  try {
    // 3. Access Token 요청
    const tokenResponse = await axios.post('https://oauth2.googleapis.com/token', {
      code,
      client_id: GOOGLE_CLIENT_ID,
      client_secret: GOOGLE_CLIENT_SECRET,
      redirect_uri: REDIRECT_URI,
      grant_type: 'authorization_code'
    });
    
    const { access_token, id_token, refresh_token } = tokenResponse.data;
    
    // 4. 사용자 정보 조회
    const userInfoResponse = await axios.get(
      'https://www.googleapis.com/oauth2/v2/userinfo',
      {
        headers: { Authorization: `Bearer ${access_token}` }
      }
    );
    
    const googleUser = userInfoResponse.data;
    
    // 5. 자체 DB에서 사용자 찾기 또는 생성
    let user = await User.findOne({ email: googleUser.email });
    
    if (!user) {
      user = await User.create({
        email: googleUser.email,
        name: googleUser.name,
        picture: googleUser.picture,
        googleId: googleUser.id
      });
    }
    
    // 6. 자체 JWT 토큰 발급
    const jwtToken = jwt.sign(
      { userId: user.id },
      JWT_SECRET,
      { expiresIn: '1h' }
    );
    
    // 7. 클라이언트로 리다이렉트
    res.redirect(`/dashboard?token=${jwtToken}`);
    
  } catch (error) {
    console.error('OAuth error:', error);
    res.redirect('/login?error=oauth_failed');
  }
});
```

### 5.4 OpenID Connect (OIDC)

OAuth 2.0 위에 구축된 인증 레이어입니다. ID Token(JWT)을 통해 사용자 정보를 제공.

```javascript
// ID Token 디코딩
const idToken = 'eyJhbGci...'; // Google에서 받은 ID Token
const decoded = jwt.decode(idToken);

console.log(decoded);
// {
//   "iss": "https://accounts.google.com",
//   "sub": "110169484474386276334",
//   "email": "user@example.com",
//   "email_verified": true,
//   "name": "John Doe",
//   "picture": "https://lh3.googleusercontent.com/...",
//   "iat": 1516239022,
//   "exp": 1516242622
// }
```

---

## 6. 클라이언트 측 저장소

### 6.1 LocalStorage

브라우저에 영구적으로 데이터를 저장하는 key-value 저장소.

**특징**:
- 용량: 약 5~10MB
- 만료 시간 없음 (영구 저장)
- 동기 API
- Origin 단위 격리
- 문자열만 저장

**API**:
```javascript
// 저장
localStorage.setItem('theme', 'dark');
localStorage.setItem('user', JSON.stringify({ name: 'John', age: 30 }));

// 조회
const theme = localStorage.getItem('theme'); // "dark"
const user = JSON.parse(localStorage.getItem('user')); // { name: 'John', age: 30 }

// 삭제
localStorage.removeItem('theme');

// 전체 삭제
localStorage.clear();

// 키 존재 여부
const hasTheme = localStorage.getItem('theme') !== null;

// 모든 키 순회
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key);
  console.log(key, value);
}
```

**사용 사례**:
```javascript
// 1. 사용자 설정
const settings = {
  theme: 'dark',
  language: 'ko',
  fontSize: 14,
  notifications: true
};
localStorage.setItem('settings', JSON.stringify(settings));

// 2. 장바구니
const cart = [
  { id: 1, name: 'Product A', quantity: 2 },
  { id: 2, name: 'Product B', quantity: 1 }
];
localStorage.setItem('cart', JSON.stringify(cart));

// 3. 폼 자동 저장
const formData = {
  title: '임시 제목',
  content: '임시 내용...'
};
localStorage.setItem('draft', JSON.stringify(formData));

// 4. 온보딩 완료 상태
localStorage.setItem('onboardingCompleted', 'true');
```

**Wrapper 클래스**:
```javascript
class Storage {
  // TTL 지원
  static setWithExpiry(key, value, ttl) {
    const item = {
      value,
      expiry: Date.now() + ttl
    };
    localStorage.setItem(key, JSON.stringify(item));
  }
  
  static getWithExpiry(key) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;
    
    try {
      const item = JSON.parse(itemStr);
      if (Date.now() > item.expiry) {
        localStorage.removeItem(key);
        return null;
      }
      return item.value;
    } catch {
      return null;
    }
  }
  
  // 용량 초과 처리
  static safeSet(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        console.error('LocalStorage quota exceeded');
        return false;
      }
      throw e;
    }
  }
}

// 사용 예
Storage.setWithExpiry('tempToken', 'abc123', 3600000); // 1시간 후 만료
const token = Storage.getWithExpiry('tempToken');
```

**⚠️ 보안 주의사항**:
```javascript
// ❌ 절대 금지
localStorage.setItem('password', userPassword);
localStorage.setItem('creditCard', cardNumber);
localStorage.setItem('accessToken', token); // XSS에 매우 취약

// ✅ 안전한 사용
localStorage.setItem('theme', 'dark');
localStorage.setItem('language', 'ko');
localStorage.setItem('cart', JSON.stringify(cartItems));
```

### 6.2 SessionStorage

탭/창 단위로 데이터를 저장.

**특징**:
- LocalStorage와 동일한 API
- 탭/창 종료 시 자동 삭제
- 같은 사이트라도 다른 탭은 별도 저장소
- 페이지 새로고침 시에는 유지

**사용 사례**:
```javascript
// 1. 다단계 폼 데이터
// Step 1
sessionStorage.setItem('step1', JSON.stringify({
  name: 'John',
  email: 'john@example.com'
}));

// Step 2
const step1Data = JSON.parse(sessionStorage.getItem('step1'));
sessionStorage.setItem('step2', JSON.stringify({
  ...step1Data,
  address: '123 Main St',
  phone: '555-1234'
}));

// 2. 검색 필터 (탭 단위)
sessionStorage.setItem('searchFilters', JSON.stringify({
  category: 'electronics',
  priceRange: [100, 500],
  sortBy: 'price'
}));

// 3. 임시 메시지
sessionStorage.setItem('flashMessage', '저장되었습니다!');
const message = sessionStorage.getItem('flashMessage');
sessionStorage.removeItem('flashMessage'); // 한 번만 표시
```

### 6.3 LocalStorage vs SessionStorage

| 특징 | LocalStorage | SessionStorage |
|------|--------------|----------------|
| 지속성 | 영구적 | 탭/창 종료 시 삭제 |
| 스코프 | Origin | Origin + 탭/창 |
| 용량 | 5~10MB | 5~10MB |
| API | 동일 | 동일 |
| 사용 사례 | 장기 설정, 캐시 | 임시 데이터, 워크플로우 |

### 6.4 IndexedDB

브라우저의 트랜잭션 기반 객체 데이터베이스.

**특징**:
- 용량: 수백 MB ~ 수 GB
- 객체, Blob, File 등 저장 가능
- 비동기 API
- 인덱스와 쿼리 지원
- 트랜잭션 지원

**기본 사용법**:
```javascript
let db;

// 1. DB 열기
const request = indexedDB.open('MyDatabase', 1);

request.onerror = (event) => {
  console.error('Database error:', event.target.error);
};

request.onsuccess = (event) => {
  db = event.target.result;
  console.log('Database opened');
};

// 2. DB 스키마 정의
request.onupgradeneeded = (event) => {
  db = event.target.result;
  
  // Object Store 생성
  const objectStore = db.createObjectStore('users', { 
    keyPath: 'id', 
    autoIncrement: true 
  });
  
  // 인덱스 생성
  objectStore.createIndex('email', 'email', { unique: true });
  objectStore.createIndex('name', 'name', { unique: false });
};

// 3. 데이터 추가
function addUser(user) {
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.add(user);
  
  request.onsuccess = () => {
    console.log('User added');
  };
}

// 4. 데이터 조회
function getUser(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.get(id);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 5. 인덱스로 조회
function getUserByEmail(email) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const index = objectStore.index('email');
    const request = index.get(email);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 6. 모든 데이터 조회
function getAllUsers() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.getAll();
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 7. 커서로 순회
function iterateUsers() {
  const transaction = db.transaction(['users'], 'readonly');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.openCursor();
  
  request.onsuccess = (event) => {
    const cursor = event.target.result;
    if (cursor) {
      console.log(cursor.key, cursor.value);
      cursor.continue();
    }
  };
}

// 8. 데이터 업데이트
function updateUser(user) {
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.put(user);
  
  request.onsuccess = () => {
    console.log('User updated');
  };
}

// 9. 데이터 삭제
function deleteUser(id) {
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.delete(id);
  
  request.onsuccess = () => {
    console.log('User deleted');
  };
}
```

**Dexie.js로 간편하게**:
```javascript
import Dexie from 'dexie';

// 1. DB 정의
const db = new Dexie('MyDatabase');

db.version(1).stores({
  users: '++id, email, name, age',
  posts: '++id, userId, title, createdAt'
});

// 2. CRUD 작업
// Create
await db.users.add({
  email: 'john@example.com',
  name: 'John Doe',
  age: 30
});

// Read
const user = await db.users.get(1);
const allUsers = await db.users.toArray();

// 쿼리
const adults = await db.users.where('age').above(18).toArray();
const john = await db.users.where('email').equals('john@example.com').first();

// Update
await db.users.update(1, { age: 31 });

// Delete
await db.users.delete(1);

// 복잡한 쿼리
const results = await db.users
  .where('age').between(20, 40)
  .and(user => user.name.startsWith('J'))
  .limit(10)
  .toArray();
```

**사용 사례**:
```javascript
// 1. 오프라인 데이터 동기화
await db.posts.bulkAdd(postsFromServer);

// 2. 대용량 이미지 캐싱
await db.images.add({
  url: 'https://example.com/image.jpg',
  blob: imageBlob,
  cachedAt: Date.now()
});

// 3. 복잡한 로컬 데이터 관리
await db.transactions.add({
  userId: 1,
  amount: 100,
  type: 'purchase',
  items: [...],
  timestamp: Date.now()
});
```

### 6.5 Cache API (Service Worker Cache)

HTTP 응답을 캐싱하는 API.

**특징**:
- Request/Response 객체 캐싱
- Service Worker와 함께 사용
- 오프라인 지원
- 프로그래매틱 제어

**Service Worker에서 사용**:
```javascript
// service-worker.js

// 1. 설치 시 정적 자산 캐싱
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll([
        '/',
        '/styles.css',
        '/script.js',
        '/logo.png'
      ]);
    })
  );
});

// 2. Fetch 가로채기
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

// 3. 캐시 업데이트
self.addEventListener('activate', (event) => {
  const cacheWhitelist = ['v2'];
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (!cacheWhitelist.includes(cacheName)) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

**일반 JavaScript에서 사용**:
```javascript
// 캐시에 저장
async function cacheData(url) {
  const cache = await caches.open('api-cache');
  const response = await fetch(url);
  await cache.put(url, response.clone());
  return response;
}

// 캐시에서 조회
async function getCachedData(url) {
  const cache = await caches.open('api-cache');
  const response = await cache.match(url);
  
  if (response) {
    return await response.json();
  }
  
  return null;
}

// 캐시 삭제
async function clearCache(cacheName) {
  await caches.delete(cacheName);
}
```

**캐싱 전략**:

1. **Cache First** (캐시 우선):
```javascript
async function cacheFirst(request) {
  const cache = await caches.open('v1');
  const cached = await cache.match(request);
  return cached || fetch(request);
}
```

2. **Network First** (네트워크 우선):
```javascript
async function networkFirst(request) {
  const cache = await caches.open('v1');
  
  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (error) {
    return await cache.match(request);
  }
}
```

3. **Stale While Revalidate** (캐시 반환 후 업데이트):
```javascript
async function staleWhileRevalidate(request) {
  const cache = await caches.open('v1');
  const cachedResponse = await cache.match(request);
  
  const fetchPromise = fetch(request).then((networkResponse) => {
    cache.put(request, networkResponse.clone());
    return networkResponse;
  });
  
  return cachedResponse || fetchPromise;
}
```

---

## 7. 저장소 비교 및 선택 가이드

### 7.1 전체 비교표

| 저장소 | 용량 | 지속성 | 스코프 | XSS 취약성 | 사용 사례 |
|--------|------|--------|--------|------------|-----------|
| Cookie (HttpOnly) | 4KB | 설정 가능 | Origin | 낮음 | 인증 토큰 |
| Cookie (일반) | 4KB | 설정 가능 | Origin | 높음 | 비권장 |
| LocalStorage | 5-10MB | 영구 | Origin | 높음 | 설정, 캐시 |
| SessionStorage | 5-10MB | 탭 종료 시 | Origin + 탭 | 높음 | 임시 데이터 |
| IndexedDB | 수백 MB~ | 영구 | Origin | 높음 | 대용량 데이터 |
| Cache API | 수백 MB~ | 영구 | Origin | 중간 | HTTP 캐싱 |
| Memory (변수) | RAM | 페이지 유지 시 | 없음 | 낮음 | Access Token |

### 7.2 선택 플로우차트

```
Q: 인증 토큰인가요?
├─ Yes → Refresh Token: HttpOnly Cookie
│         Access Token: Memory (변수)
└─ No
    │
    Q: 대용량 데이터인가요? (>5MB)
    ├─ Yes
    │   ├─ 구조화된 데이터 → IndexedDB
    │   └─ HTTP 응답 → Cache API
    └─ No
        │
        Q: 탭을 닫으면 삭제되어야 하나요?
        ├─ Yes → SessionStorage
        └─ No → LocalStorage
```

### 7.3 실전 조합 예시

```javascript
// 완전한 인증 시스템
class AuthManager {
  // Access Token: 메모리
  #accessToken = null;
  
  async login(email, password) {
    const { data } = await axios.post('/api/login', { email, password }, {
      withCredentials: true // Refresh Token 쿠키 받기
    });
    
    // Access Token은 메모리에만
    this.#accessToken = data.accessToken;
    
    // 사용자 설정은 LocalStorage
    localStorage.setItem('user', JSON.stringify(data.user));
    localStorage.setItem('preferences', JSON.stringify(data.preferences));
    
    return data.user;
  }
  
  async refreshToken() {
    const { data } = await axios.post('/api/refresh', {}, {
      withCredentials: true
    });
    this.#accessToken = data.accessToken;
  }
  
  async logout() {
    await axios.post('/api/logout', {}, {
      withCredentials: true
    });
    
    this.#accessToken = null;
    localStorage.removeItem('user');
    localStorage.removeItem('preferences');
  }
  
  getAccessToken() {
    return this.#accessToken;
  }
}

// 대용량 오프라인 데이터
class OfflineDataManager {
  constructor() {
    this.db = new Dexie('OfflineDB');
    this.db.version(1).stores({
      posts: '++id, userId, createdAt',
      images: 'url, blob, cachedAt'
    });
  }
  
  async syncPosts() {
    const posts = await fetch('/api/posts').then(r => r.json());
    await this.db.posts.bulkPut(posts);
  }
  
  async getPosts() {
    return await this.db.posts.toArray();
  }
}

// 임시 폼 데이터
class FormManager {
  saveDraft(formId, data) {
    sessionStorage.setItem(`draft-${formId}`, JSON.stringify(data));
  }
  
  loadDraft(formId) {
    const draft = sessionStorage.getItem(`draft-${formId}`);
    return draft ? JSON.parse(draft) : null;
  }
  
  clearDraft(formId) {
    sessionStorage.removeItem(`draft-${formId}`);
  }
}

// API 응답 캐싱
class APICache {
  async fetch(url, options = {}) {
    const cache = await caches.open('api-cache');
    const cached = await cache.match(url);
    
    if (cached && !options.refresh) {
      return cached.json();
    }
    
    const response = await fetch(url);
    cache.put(url, response.clone());
    return response.json();
  }
}
```

---

## 8. 보안 Best Practices

### 8.1 토큰 저장 전략

**❌ 절대 하지 말아야 할 것**:
```javascript
// LocalStorage에 민감한 정보
localStorage.setItem('accessToken', token);
localStorage.setItem('password', password);
localStorage.setItem('creditCard', cardNumber);

// 일반 쿠키에 토큰
document.cookie = `token=${token}`;
```

**✅ 권장 방식**:
```javascript
// 1. Refresh Token: HttpOnly Cookie (서버에서 설정)
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,    // JavaScript 접근 불가
  secure: true,      // HTTPS only
  sameSite: 'strict',// CSRF 방어
  maxAge: 7 * 24 * 60 * 60 * 1000
});

// 2. Access Token: 메모리 (변수)
let accessToken = null;

function setAccessToken(token) {
  accessToken = token;
}

function getAccessToken() {
  return accessToken;
}

// 3. 비민감 데이터: LocalStorage
localStorage.setItem('theme', 'dark');
localStorage.setItem('language', 'ko');
```

### 8.2 XSS 방어

```javascript
// 1. 사용자 입력 Sanitize
import DOMPurify from 'dompurify';

const userInput = req.body.comment;
const clean = DOMPurify.sanitize(userInput);

// 2. CSP 헤더 설정
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'nonce-random123'; style-src 'self' 'unsafe-inline'"
  );
  next();
});

// 3. 출력 시 이스케이프
// React는 자동으로 이스케이프
<div>{userInput}</div>

// 직접 HTML 삽입 시 주의
<div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(html)}} />
```

### 8.3 CSRF 방어

```javascript
// 1. SameSite Cookie
res.cookie('sessionId', sessionId, {
  sameSite: 'strict' // 또는 'lax'
});

// 2. CSRF Token
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get('/form', (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});

app.post('/process', csrfProtection, (req, res) => {
  // CSRF 토큰 검증 통과
  res.send('Data processed');
});

// 3. Double Submit Cookie
app.post('/api/action', (req, res) => {
  const cookieToken = req.cookies.csrfToken;
  const headerToken = req.headers['x-csrf-token'];
  
  if (cookieToken !== headerToken) {
    return res.status(403).json({ error: 'CSRF token mismatch' });
  }
  
  // 처리 계속
});
```

### 8.4 종합 보안 체크리스트

**쿠키**:
- ✅ HttpOnly 설정
- ✅ Secure 설정 (프로덕션)
- ✅ SameSite 설정
- ✅ 적절한 만료 시간
- ✅ 도메인/경로 제한

**LocalStorage/SessionStorage**:
- ✅ 민감한 정보 저장 금지
- ✅ XSS 방어 (입력 sanitize)
- ✅ 용량 초과 처리
- ✅ 만료 시간 구현 (필요시)

**JWT**:
- ✅ 강력한 시크릿 키 (256비트 이상)
- ✅ 짧은 만료 시간 (Access Token)
- ✅ Refresh Token 로테이션
- ✅ 알고리즘 명시
- ✅ Payload에 민감 정보 제외

**API**:
- ✅ HTTPS 사용
- ✅ Rate Limiting
- ✅ CORS 정책 설정
- ✅ 입력 검증
- ✅ SQL Injection 방어

---

## 9. 실전 예제

### 9.1 인증 시스템

```javascript
// ===== Backend (Node.js/Express) =====

const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const cookieParser = require('cookie-parser');
const { body, validationResult } = require('express-validator');

const app = express();
app.use(express.json());
app.use(cookieParser());

const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET;
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;

// 회원가입
app.post('/api/register',
  [
    body('email').isEmail(),
    body('password').isLength({ min: 8 })
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    const { email, password } = req.body;
    
    // 중복 체크
    const existing = await User.findOne({ email });
    if (existing) {
      return res.status(409).json({ error: 'Email already exists' });
    }
    
    // 비밀번호 해싱
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // 사용자 생성
    const user = await User.create({
      email,
      password: hashedPassword
    });
    
    res.status(201).json({ 
      message: 'User created',
      userId: user.id
    });
  }
);

// 로그인
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  
  // 사용자 조회
  const user = await User.findOne({ email });
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // 비밀번호 확인
  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Access Token 생성
  const accessToken = jwt.sign(
    { 
      userId: user.id,
      email: user.email,
      role: user.role
    },
    ACCESS_SECRET,
    { expiresIn: '15m' }
  );
  
  // Refresh Token 생성
  const refreshToken = jwt.sign(
    { userId: user.id },
    REFRESH_SECRET,
    { expiresIn: '7d' }
  );
  
  // Refresh Token DB 저장
  await RefreshToken.create({
    userId: user.id,
    token: refreshToken,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });
  
  // Refresh Token을 HttpOnly 쿠키로
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000
  });
  
  // Access Token은 응답으로
  res.json({
    accessToken,
    user: {
      id: user.id,
      email: user.email,
      role: user.role
    }
  });
});

// Access Token 재발급
app.post('/api/refresh', async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  
  if (!refreshToken) {
    return res.status(401).json({ error: 'No refresh token' });
  }
  
  try {
    // Refresh Token 검증
    const decoded = jwt.verify(refreshToken, REFRESH_SECRET);
    
    // DB에서 확인
    const storedToken = await RefreshToken.findOne({
      userId: decoded.userId,
      token: refreshToken
    });
    
    if (!storedToken) {
      return res.status(403).json({ error: 'Invalid refresh token' });
    }
    
    // 새 Access Token 발급
    const accessToken = jwt.sign(
      { userId: decoded.userId },
      ACCESS_SECRET,
      { expiresIn: '15m' }
    });
    
    res.json({ accessToken });
  } catch (err) {
    return res.status(403).json({ error: 'Invalid refresh token' });
  }
});

// 로그아웃
app.post('/api/logout', authenticateToken, async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  
  // DB에서 Refresh Token 삭제
  await RefreshToken.destroy({
    where: { token: refreshToken }
  });
  
  res.clearCookie('refreshToken');
  res.json({ message: 'Logged out successfully' });
});

// 인증 미들웨어
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, ACCESS_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    if (err.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired' });
    }
    return res.status(403).json({ error: 'Invalid token' });
  }
}

// 보호된 라우트
app.get('/api/profile', authenticateToken, async (req, res) => {
  const user = await User.findByPk(req.user.userId);
  res.json(user);
});

// ===== Frontend (React) =====

import axios from 'axios';

// Access Token을 메모리에 저장
let accessToken = null;

// Axios 인스턴스 생성
const api = axios.create({
  baseURL: 'http://localhost:3000/api',
  withCredentials: true // 쿠키 전송
});

// Request 인터셉터
api.interceptors.request.use(
  (config) => {
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response 인터셉터 - 토큰 만료 시 재발급
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const { data } = await api.post('/refresh');
        accessToken = data.accessToken;
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh도 실패 - 로그인 페이지로
        accessToken = null;
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

// Auth Hook
function useAuth() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // 초기 로드 시 토큰 재발급 시도
  useEffect(() => {
    const initAuth = async () => {
      try {
        const { data } = await api.post('/refresh');
        accessToken = data.accessToken;
        
        const userResponse = await api.get('/profile');
        setUser(userResponse.data);
      } catch (error) {
        console.log('Not authenticated');
      } finally {
        setLoading(false);
      }
    };
    
    initAuth();
  }, []);
  
  const login = async (email, password) => {
    const { data } = await api.post('/login', { email, password });
    accessToken = data.accessToken;
    setUser(data.user);
    
    // 사용자 설정 LocalStorage에 저장
    localStorage.setItem('userPreferences', JSON.stringify({
      theme: 'light',
      language: 'ko'
    }));
    
    return data.user;
  };
  
  const logout = async () => {
    await api.post('/logout');
    accessToken = null;
    setUser(null);
    localStorage.removeItem('userPreferences');
  };
  
  return { user, loading, login, logout };
}

// 사용 예
function App() {
  const { user, loading, login, logout } = useAuth();
  
  if (loading) return <div>Loading...</div>;
  
  if (!user) {
    return <LoginForm onLogin={login} />;
  }
  
  return (
    <div>
      <h1>Welcome, {user.email}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

### 9.2 오프라인 우선 애플리케이션

```javascript
// Service Worker + IndexedDB + Cache API

// service-worker.js
const CACHE_NAME = 'app-v1';
const STATIC_CACHE = [
  '/',
  '/index.html',
  '/styles.css',
  '/app.js'
];

// 설치
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(STATIC_CACHE);
    })
  );
});

// Fetch 전략
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // API 요청
  if (request.url.includes('/api/')) {
    event.respondWith(networkFirstStrategy(request));
  }
  // 정적 자산
  else {
    event.respondWith(cacheFirstStrategy(request));
  }
});

async function networkFirstStrategy(request) {
  const cache = await caches.open(CACHE_NAME);
  
  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (error) {
    const cached = await cache.match(request);
    return cached || new Response('Offline', { status: 503 });
  }
}

async function cacheFirstStrategy(request) {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);
  
  if (cached) return cached;
  
  const response = await fetch(request);
  cache.put(request, response.clone());
  return response;
}

// app.js - IndexedDB 활용
import Dexie from 'dexie';

class OfflineApp {
  constructor() {
    this.db = new Dexie('OfflineAppDB');
    this.db.version(1).stores({
      posts: '++id, title, content, synced, createdAt',
      syncQueue: '++id, action, data, timestamp'
    });
  }
  
  // 게시물 생성 (오프라인 대응)
  async createPost(title, content) {
    const post = {
      title,
      content,
      synced: false,
      createdAt: new Date().toISOString()
    };
    
    // IndexedDB에 저장
    const id = await this.db.posts.add(post);
    
    // 동기화 큐에 추가
    await this.db.syncQueue.add({
      action: 'CREATE_POST',
      data: { ...post, id },
      timestamp: Date.now()
    });
    
    // 온라인이면 즉시 동기화
    if (navigator.onLine) {
      await this.syncData();
    }
    
    return id;
  }
  
  // 서버와 동기화
  async syncData() {
    const queue = await this.db.syncQueue.toArray();
    
    for (const item of queue) {
      try {
        if (item.action === 'CREATE_POST') {
          const response = await fetch('/api/posts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(item.data)
          });
          
          const serverPost = await response.json();
          
          // IndexedDB 업데이트
          await this.db.posts.update(item.data.id, {
            synced: true,
            serverId: serverPost.id
          });
          
          // 큐에서 제거
          await this.db.syncQueue.delete(item.id);
        }
      } catch (error) {
        console.error('Sync failed:', error);
        break; // 실패하면 중단
      }
    }
  }
  
  // 게시물 목록 조회
  async getPosts() {
    return await this.db.posts.orderBy('createdAt').reverse().toArray();
  }
}

// 온라인/오프라인 이벤트 처리
const app = new OfflineApp();

window.addEventListener('online', () => {
  console.log('Online - syncing data...');
  app.syncData();
});

window.addEventListener('offline', () => {
  console.log('Offline - data will be synced when online');
});
```

### 9.3 보안 강화 쿠키 설정

```javascript
// 프로덕션 레벨 쿠키 설정

const cookieConfig = {
  // 개발 환경
  development: {
    httpOnly: true,
    secure: false, // localhost는 HTTP
    sameSite: 'lax',
    maxAge: 24 * 60 * 60 * 1000,
    path: '/'
  },
  
  // 프로덕션 환경
  production: {
    httpOnly: true,
    secure: true, // HTTPS 필수
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
    domain: '.example.com', // 서브도메인 포함
    path: '/'
  }
};

const config = cookieConfig[process.env.NODE_ENV];

// Refresh Token 쿠키
res.cookie('refreshToken', token, {
  ...config,
  httpOnly: true,
  signed: true // 쿠키 서명
});

// CSRF Token 쿠키
res.cookie('csrfToken', csrfToken, {
  ...config,
  httpOnly: false, // JavaScript 접근 허용 (헤더로 전송용)
  maxAge: 60 * 60 * 1000 // 1시간
});
```

---

## 10. 마무리 및 권장사항

### 10.1 인증 방식 선택 가이드

**전통적인 웹 애플리케이션** (SSR):
- 세션 + HttpOnly Cookie
- 서버 렌더링 페이지
- 단일 도메인

**모던 SPA/API 서버**:
- JWT (Access + Refresh Token)
- Access Token: 메모리
- Refresh Token: HttpOnly Cookie
- RESTful API

**마이크로서비스**:
- JWT
- API Gateway에서 토큰 검증
- 서비스 간 토큰 전달

**모바일 앱**:
- JWT
- Secure Storage에 Refresh Token 저장
- Access Token은 메모리

### 10.2 저장소 사용 원칙

1. **민감한 정보는 절대 LocalStorage/SessionStorage에 저장 금지**
2. **인증 토큰은 가능한 한 메모리 + HttpOnly Cookie 조합**
3. **대용량 데이터는 IndexedDB 사용**
4. **정적 자산 캐싱은 Cache API + Service Worker**
5. **임시 데이터는 SessionStorage**
6. **사용자 설정은 LocalStorage (비민감 정보만)**

### 10.3 보안 체크리스트

- [ ] HTTPS 사용
- [ ] HttpOnly, Secure, SameSite 쿠키 설정
- [ ] Access Token 짧은 만료 시간 (15분~1시간)
- [ ] Refresh Token 로테이션 구현
- [ ] XSS 방어 (입력 sanitize, CSP)
- [ ] CSRF 방어 (SameSite, CSRF Token)
- [ ] Rate Limiting 구현
- [ ] 비밀번호 해싱 (bcrypt, Argon2)
- [ ] SQL Injection 방어 (Prepared Statements)
- [ ] CORS 정책 엄격히 설정

### 10.4 성능 최적화

```javascript
// 1. LocalStorage 래퍼로 직렬화 최적화
class FastStorage {
  static get(key) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch {
      return null;
    }
  }
  
  static set(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        this.clearOldest();
        return this.set(key, value);
      }
      return false;
    }
  }
  
  static clearOldest() {
    // 타임스탬프 기반으로 가장 오래된 항목 삭제
    const items = Object.keys(localStorage)
      .map(key => ({
        key,
        data: this.get(key)
      }))
      .filter(item => item.data?.timestamp)
      .sort((a, b) => a.data.timestamp - b.data.timestamp);
    
    if (items.length > 0) {
      localStorage.removeItem(items[0].key);
    }
  }
}

// 2. IndexedDB 배치 작업
async function batchInsert(data) {
  await db.transaction('rw', db.posts, async () => {
    await db.posts.bulkAdd(data);
  });
}

// 3. Cache API 프리페칭
async function prefetchResources() {
  const cache = await caches.open('prefetch');
  const urls = ['/api/popular', '/api/trending'];
  await cache.addAll(urls);
}
```

### 10.5 디버깅 팁

```javascript
// LocalStorage 모니터링
window.addEventListener('storage', (e) => {
  console.log('Storage changed:', {
    key: e.key,
    oldValue: e.oldValue,
    newValue: e.newValue,
    url: e.url
  });
});

// IndexedDB 상태 확인
async function debugIndexedDB() {
  const dbs = await indexedDB.databases();
  console.log('Available databases:', dbs);
  
  const db = await openDB();
  const stores = db.objectStoreNames;
  console.log('Object stores:', stores);
}

// 쿠키 확인
console.log('Cookies:', document.cookie);

// Cache API 확인
const cacheNames = await caches.keys();
console.log('Caches:', cacheNames);
```

---

## 참고 자료

- [MDN Web Docs - HTTP Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [MDN Web Docs - Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)
- [MDN Web Docs - IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- [JWT.io](https://jwt.io/)
- [OAuth 2.0 RFC 6749](https://tools.ietf.org/html/rfc6749)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
