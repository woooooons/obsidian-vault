---
title: 현대 애플리케이션 통신 방식
date: 2025-12-07
tags:
  - it
  - 개발
  - 백앤드
  - 통신방식
---

## 주요 통신 방식 비교표

|구분|REST API|gRPC|WebSocket|GraphQL|메시지 큐|웹훅|SSE|WebRTC|MQTT|Long Polling|
|---|---|---|---|---|---|---|---|---|---|---|
|**핵심 개념**|자원 중심 아키텍처|원격 함수 호출|양방향 실시간 통신|쿼리 언어 기반 API|비동기 메시지 큐잉|이벤트 기반 콜백|서버→클라이언트 스트리밍|P2P 미디어 통신|IoT 경량 프로토콜|HTTP 요청 유지 방식|
|**통신 방향**|단방향 (요청→응답)|양방향 가능|완전 양방향|단방향 (요청→응답)|단방향 (발행→구독)|단방향 (이벤트→알림)|단방향 (서버→클라이언트)|양방향 P2P|양방향 (Pub/Sub)|단방향 (요청→응답)|
|**연결 방식**|요청마다 연결/해제|지속 연결 가능|지속 연결 필수|요청마다 연결/해제|중개자(브로커) 통한 연결|HTTP 콜백|지속 연결|직접 P2P 연결|브로커 통한 연결|요청 유지|
|**데이터 형식**|JSON (주로)|Protobuf (바이너리)|제한 없음 (주로 JSON)|JSON|제한 없음|JSON (주로)|Text/JSON|바이너리 (미디어)|바이너리/텍스트|JSON (주로)|
|**프로토콜**|HTTP/HTTPS|HTTP/2|WebSocket|HTTP/HTTPS|AMQP, MQTT 등|HTTP/HTTPS|HTTP|UDP 기반|TCP/IP|HTTP/HTTPS|
|**실시간성**|낮음|중간|매우 높음|낮음|중간|중간|높음|매우 높음 (초저지연)|높음|낮음|
|**성능**|보통|매우 빠름|빠름|보통|매우 안정적|보통|빠름|매우 빠름|가벼움|비효율적|
|**브라우저 지원**|완벽|제한적 (gRPC-Web 필요)|완벽|완벽|불가 (서버 사이드)|불가 (수신측)|완벽|완벽|제한적|완벽|

---

## 1. REST API

**"웹의 표준 언어"**

### 특징

- HTTP 메서드 사용 (GET, POST, PUT, DELETE)
- URL이 자원을 나타냄 (`/users/123`, `/posts`)
- Stateless (무상태) - 각 요청은 독립적임
- 캐싱 친화적

### 장점

- 압도적인 범용성과 생태계
- 누구나 이해하기 쉬움
- 브라우저에서 바로 테스트 가능
- 방화벽 통과 용이

### 단점

- Over-fetching / Under-fetching (불필요한 데이터 전송)
- 여러 리소스 요청 시 다중 요청 필요
- 실시간 통신 불가

### 사용 예시

```
GET /api/users/123
→ 사용자 정보 전체 반환

POST /api/orders
→ 새 주문 생성
```

---

## 2. gRPC

**"마이크로서비스의 고속도로"**

### 특징

- Protocol Buffers로 데이터 직렬화
- HTTP/2 기반 (멀티플렉싱, 헤더 압축)
- 강력한 타입 시스템
- 4가지 통신 패턴 지원 (Unary, Server Streaming, Client Streaming, Bidirectional Streaming)

### 장점

- 최고 수준의 성능 (REST 대비 7~10배 빠름)
- 자동 코드 생성
- 양방향 스트리밍 지원
- 강력한 타입 안정성

### 단점

- 브라우저 직접 지원 제한적 (gRPC-Web 필요)
- 바이너리라 사람이 읽기 어려움
- 러닝 커브 있음

### 사용 예시

```protobuf
service UserService {
  rpc GetUser(UserId) returns (User);
  rpc StreamUsers(Empty) returns (stream User);
}
```

---

## 3. WebSocket

**"실시간 양방향 고속도로"**

### 특징

- 단 한 번의 핸드셰이크 후 지속 연결
- 서버→클라이언트 푸시 가능
- 낮은 오버헤드 (헤더가 작음)

### 장점

- 실시간성 최고
- 낮은 지연 시간
- 양방향 통신 자유로움
- 브라우저 네이티브 지원

### 단점

- 연결 관리 복잡함
- 수평 확장 어려움 (Sticky Session 필요)
- REST 같은 표준 구조 없음
- 방화벽/프록시에서 차단될 수 있음

### 사용 예시

```javascript
const ws = new WebSocket('ws://server.com');
ws.onmessage = (event) => {
  console.log('새 메시지:', event.data);
};
```

---

## 4. GraphQL

**"데이터 맞춤 주문 서비스"**

### 특징

- 클라이언트가 필요한 데이터만 요청
- 단일 엔드포인트 (`/graphql`)
- 스키마 기반 강력한 타입 시스템
- 실시간 구독(Subscription) 지원

### 장점

- Over-fetching / Under-fetching 해결
- 한 번의 요청으로 여러 리소스 조회
- API 버전 관리 불필요
- 개발자 경험 우수 (자동 문서화, 타입 체크)

### 단점

- 서버 구현 복잡도 높음
- 캐싱 전략 어려움
- N+1 쿼리 문제 주의 필요
- 파일 업로드 등 특수 기능 구현 복잡

### 사용 예시

```graphql
query {
  user(id: "123") {
    name
    email
    posts(limit: 3) {
      title
      createdAt
    }
  }
}
```

---

## 5. 메시지 큐 (RabbitMQ, Kafka, AWS SQS)

**"안전한 비동기 우체국"**

### 특징

- Producer-Consumer 패턴
- 메시지 브로커가 중개
- 메시지 영속성 보장
- Pub/Sub, Queue, Topic 등 다양한 패턴

### 장점

- 시스템 간 결합도 최소화
- 트래픽 급증 시 버퍼 역할
- 장애 격리 (한 서비스 장애가 전파 안 됨)
- 재시도 및 실패 처리 용이

### 단점

- 즉각적인 응답 불가
- 인프라 복잡도 증가
- 메시지 순서 보장 복잡
- 디버깅 어려움

### 사용 예시

```
[주문 서비스] 
    ↓ 메시지 발행
[RabbitMQ 큐]
    ↓ 메시지 소비
[결제 서비스] → [배송 서비스] → [알림 서비스]
```

---

## 6. 웹훅 (Webhook)

**"나 변했어, 알려줄게"**

### 특징

- 역방향 API (서버가 클라이언트 호출)
- 이벤트 발생 시 자동 알림
- HTTP POST로 구현

### 장점

- 폴링 불필요 (서버 부하 감소)
- 실시간 이벤트 처리
- 구현 간단

### 단점

- 수신 측 엔드포인트 필요 (공개 URL)
- 전달 보장 어려움
- 보안 고려 필요 (서명 검증)
- 재시도 로직 직접 구현

### 사용 예시

```
[GitHub] → (코드 푸시 이벤트)
    ↓ POST https://my-ci.com/webhook
[CI/CD 서버] → 자동 빌드 시작
```

---

## 7. Server-Sent Events (SSE)

**"서버의 단방향 방송"**

### 특징

- 서버→클라이언트 단방향 실시간 스트리밍
- HTTP 기반
- EventSource API 사용
- 자동 재연결 기능

### 장점

- 구현 매우 간단
- HTTP 기반이라 방화벽 통과 쉬움
- 자동 재연결 지원
- 텍스트 기반이라 디버깅 용이

### 단점

- 단방향만 가능 (서버→클라이언트)
- 브라우저 연결 수 제한 (보통 6개)
- 바이너리 데이터 전송 불편
- IE 미지원

### 사용 예시

```javascript
const eventSource = new EventSource('/api/notifications');
eventSource.onmessage = (event) => {
  console.log('알림:', event.data);
};
```

---

## 8. WebRTC

**"P2P 직통 연결"**

### 특징

- Peer-to-Peer 직접 연결
- UDP 기반 실시간 미디어 통신
- NAT traversal (STUN/TURN 사용)
- 오디오, 비디오, 데이터 채널 지원

### 장점

- 초저지연 (수십 ms)
- 서버 부하 최소화
- 고품질 스트리밍
- 브라우저 네이티브 지원

### 단점

- NAT/방화벽 통과 복잡 (STUN/TURN 서버 필요)
- 브라우저 간 호환성 이슈
- 구현 복잡도 높음
- 연결 수 증가 시 P2P 한계

### 사용 예시

```javascript
const pc = new RTCPeerConnection();
pc.ontrack = (event) => {
  videoElement.srcObject = event.streams[0];
};
```

---

## 9. MQTT

**"IoT의 경량 전령"**

### 특징

- Publish/Subscribe 패턴
- 경량 프로토콜 (저전력, 저대역폭)
- QoS (Quality of Service) 레벨 지원
- Topic 기반 메시징

### 장점

- 매우 가벼움 (헤더 2바이트)
- 불안정한 네트워크에 강함
- 배터리 효율적
- 대규모 IoT 디바이스 지원

### 단점

- 웹 브라우저 직접 지원 제한적 (MQTT over WebSocket 필요)
- 보안 기능 제한적 (별도 구현 필요)
- 대용량 데이터 전송 부적합

### 사용 예시

```python
client.publish("home/temperature", "23.5")
client.subscribe("home/+/status")
```

---

## 10. Long Polling

**"구형 실시간 흉내"**

### 특징

- HTTP 요청을 길게 유지
- 이벤트 발생 시 응답 후 즉시 재연결
- WebSocket 이전 실시간 구현 방식

### 장점

- 구현 간단
- 구형 브라우저 지원
- 방화벽 통과 용이
- 서버 푸시 흉내 가능

### 단점

- 매우 비효율적 (연결/재연결 반복)
- 서버 부하 높음
- 지연 시간 길음
- 리소스 낭비

### 사용 예시

```javascript
function longPoll() {
  fetch('/api/updates')
    .then(res => res.json())
    .then(data => {
      console.log(data);
      longPoll(); // 즉시 재연결
    });
}
```

---

## 선택 가이드

|상황|추천 방식|
|---|---|
|공개 API 제공|REST|
|마이크로서비스 내부 통신|gRPC|
|웹 채팅, 실시간 게임|WebSocket|
|모바일 앱 API|GraphQL|
|대용량 트래픽 처리|메시지 큐|
|외부 서비스 이벤트 수신|웹훅|
|IoT 디바이스 통신|MQTT|
|화상 회의|WebRTC|
|실시간 알림 (단방향)|SSE|
|레거시 실시간 지원|Long Polling|

---

## 실전 조합 예시

### E커머스 시스템

- 프론트엔드↔백엔드: REST API (상품 조회)
- 실시간 재고 업데이트: WebSocket
- 주문 처리: 메시지 큐 (Kafka)
- 결제 완료 알림: 웹훅 (PG사→우리 서버)
- 마이크로서비스 간 통신: gRPC

### SNS 앱

- 피드 조회: GraphQL
- 실시간 채팅: WebSocket
- 알림 푸시: SSE
- 이미지 업로드: REST API
- 분석 데이터 수집: 메시지 큐

### 화상 회의 플랫폼

- 비디오/오디오: WebRTC
- 채팅: WebSocket
- 사용자 인증: REST API
- 녹화 파일 저장: 메시지 큐
- 참여자 알림: SSE

### 스마트홈 시스템

- IoT 센서 데이터: MQTT
- 모바일 앱 API: GraphQL
- 실시간 제어: WebSocket
- 외부 서비스 연동: 웹훅

---

만능 기술은 없음. 문제에 맞는 도구를 선택하는 게 핵심임.

---

## 참고 링크

### REST API

- https://restfulapi.net/
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods

### gRPC

- https://grpc.io/docs/
- https://github.com/grpc/grpc

### WebSocket

- https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
- https://websocket.org/

### GraphQL

- https://graphql.org/learn/
- https://www.apollographql.com/docs/

### 메시지 큐

- RabbitMQ: https://www.rabbitmq.com/documentation.html
- Apache Kafka: https://kafka.apache.org/documentation/
- AWS SQS: https://aws.amazon.com/sqs/

### 웹훅

- https://en.wikipedia.org/wiki/Webhook
- https://github.com/github/docs/webhooks

### SSE (Server-Sent Events)

- https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events
- https://html.spec.whatwg.org/multipage/server-sent-events.html

### WebRTC

- https://webrtc.org/
- https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API

### MQTT

- https://mqtt.org/
- https://www.hivemq.com/mqtt/

### Long Polling

- https://javascript.info/long-polling
- https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest