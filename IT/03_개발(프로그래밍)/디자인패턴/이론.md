---
title: 디자인패턴 이론
date: 2025-12-03
tags:
  - it
  - 개발
  - 디자인패턴
---
# 1. 생성(Creational) 패턴

## 1-1. Singleton

**정의**  
시스템 전체에서 단 하나의 인스턴스만 유지하고, 전역적 접근점을 제공하는 패턴.

**언제 쓰는가**

- 설정(config) 객체
    
- 커넥션 풀
    
- 로깅 시스템
    
- 글로벌 캐시
    

**핵심 개념**

- 인스턴스가 여러 개 생성되면 문제 생기는 자원 관리
    
- 생성 제어를 통해 충돌 방지
    

**장점**

- 전역 상태 관리
    
- 불필요한 객체 생성 방지
    

**주의점**

- 전역 상태가 많아지면 테스트 어려움
    
- 멀티스레드 환경에서는 동기화 필수
    

---

## 1-2. Factory Method

**정의**  
객체 생성 로직을 서브클래스 또는 외부 함수에 위임하는 패턴.

**언제 쓰는가**

- 객체 타입을 런타임에서 결정해야 할 때
    
- 생성 과정이 복잡하거나 조건이 많을 때
    

**핵심 개념**

- 생성자 호출을 직접 하지 않고 “생성 책임”을 다른 곳으로 분리
    

**장점**

- 객체 생성 변경에 따른 영향 최소화
    
- 코드 확장 용이
    

**주의점**

- 단순한 생성까지 굳이 패턴으로 만들면 불필요한 구조만 늘어남
    

---

## 1-3. Builder

**정의**  
복잡한 객체를 단계별로 조립할 수 있게 하는 패턴.

**언제 쓰는가**

- 필드가 많고, 생성 순서나 옵션 조합이 다양한 객체
    
- 가독성이 떨어지는 긴 생성자를 대체
    

**핵심 개념**

- 객체를 단계적으로 구성
    
- 동일한 생성 절차에서 다양한 조합 생성 가능
    

**장점**

- 명확한 객체 조립 과정
    
- 유연한 옵션 관리
    

**주의점**

- 단순 객체에는 과한 구조
    

---

# 2. 구조(Structural) 패턴

## 2-1. Adapter

**정의**  
서로 다른 인터페이스를 가진 객체를 연결해 호환되게 만드는 패턴.

**언제 쓰는가**

- 기존 시스템과 새 시스템의 인터페이스가 맞지 않을 때
    
- 외부 라이브러리 교체 시 일관된 인터페이스 유지
    

**핵심 개념**

- 변환기(Wrapper)를 통해 API를 통일
    

**장점**

- 코드 변경 없이 새로운 시스템 적용
    
- 모듈 간 결합도 감소
    

**주의점**

- 너무 많이 쓰면 불명확한 구조 발생
    

---

## 2-2. Decorator

**정의**  
기존 객체에 기능을 동적으로 추가하는 패턴.

**언제 쓰는가**

- 기능을 계층적으로 확장해야 할 때 (로그, 인증, 캐싱)
    
- 상속보다 구성 기반 확장을 원할 때
    

**핵심 개념**

- 객체를 감싸며 기능을 확장
    
- 원래 객체의 인터페이스를 유지
    

**장점**

- 런타임에서 기능을 쉽게 추가/제거
    
- 개방폐쇄 원칙(OCP) 준수
    

**주의점**

- 데코레이터가 중첩되면 디버깅 어려움
    

---

## 2-3. Facade

**정의**  
복잡한 서브시스템에 대해 단순한 인터페이스를 제공하는 패턴.

**언제 쓰는가**

- 하위 모듈이 너무 복잡해 외부 노출을 줄이고 싶을 때
    
- API 사용을 단순화하고 싶을 때
    

**핵심 개념**

- 복잡한 로직을 통합한 단일 진입점 제공
    

**장점**

- 시스템 학습 비용 감소
    
- 모듈 간 의존성 감소
    

**주의점**

- 과한 Facade는 실제 복잡성을 숨겨 관리 어려움
    

---

# 3. 행위(Behavioral) 패턴

## 3-1. Strategy

**정의**  
알고리즘을 객체로 캡슐화하여 교체 가능하게 만드는 패턴.

**언제 쓰는가**

- 데이터 처리 방법이나 정책을 상황에 따라 바꿔야 할 때
    
- 인증 방식, 정렬 방식, 계산 로직을 유연하게 변경할 때
    

**핵심 개념**

- 알고리즘을 분리하고 컨텍스트가 선택
    

**장점**

- 조건문 제거
    
- 알고리즘 변경 용이
    

**주의점**

- 전략 종류가 너무 많으면 관리 복잡
    

---

## 3-2. Observer

**정의**  
객체의 상태 변화가 발생하면 여러 구독자에게 자동으로 알리는 패턴.

**언제 쓰는가**

- 이벤트 기반 시스템
    
- Pub/Sub 구조
    
- UI 상태 업데이트
    

**핵심 개념**

- 관찰 대상 → 구독자 구조
    
- 느슨한 결합
    

**장점**

- 이벤트 처리 확장성 높음
    
- 동적 구독/해지 가능
    

**주의점**

- 순환 의존이 생기면 문제 발생
    
- 구독 해제가 제대로 되지 않으면 메모리 누수
    

---

## 3-3. Command

**정의**  
요청을 객체로 캡슐화하여 호출자와 실행자를 분리하는 패턴.

**언제 쓰는가**

- 작업 큐 시스템
    
- 되돌리기(Undo) 기능
    
- 사용자 입력을 명령 단위로 기록할 때
    

**핵심 개념**

- 요청을 객체로 저장
    
- 실행·취소·재실행 구조 가능
    

**장점**

- 명령 이력 관리 가능
    
- 호출자/수행자의 완전 분리
    

**주의점**

- 명령 객체가 많아질 수 있음
    

---

## 3-4. State

**정의**  
객체의 내부 상태가 바뀌면 동작도 함께 변경되는 패턴.

**언제 쓰는가**

- 상태에 따라 행동이 명확히 달라지는 경우
    
- FSM(Finite State Machine) 모델링
    

**핵심 개념**

- 상태를 객체로 분리
    
- 상태 전환 로직 명확화
    

**장점**

- if-else 대량 제거
    
- 상태·행동 구조가 명확해짐
    

**주의점**

- 상태가 많으면 복잡해짐
    

---

# 4. 카테고리 전체를 관통하는 핵심 개념

## 4-1. 생성 패턴이 필요한 이유

- 객체 생성 방식이 그대로 로직에 섞이면 유지보수가 어려워짐
    
- 생성 책임을 분리하면 확장성 증가
    

## 4-2. 구조 패턴이 필요한 이유

- 모듈 간 인터페이스가 달라지면 시스템 전체가 깨짐
    
- 구조적 결합도를 낮추는 것이 핵심
    

## 4-3. 행위 패턴이 필요한 이유

- 조건문 난무, 중복 로직, 변경이 어려운 알고리즘 구조 해결
    
- “행동의 변경 가능성”을 위해 분리와 유연성을 부여
    

---

# 5. 실무에서 가장 많이 쓰이는 패턴 TOP 5

1. Strategy – 정책·알고리즘 교체
    
2. Decorator – middleware, logging, auth
    
3. Facade – 복잡한 서비스의 단일 API 제공
    
4. Observer – 이벤트 기반 시스템
    
5. Factory – 설정 기반 객체 생성
    


