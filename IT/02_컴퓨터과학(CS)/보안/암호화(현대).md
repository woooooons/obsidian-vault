---
title: 암호화(현대)
date: 2026-01-06
---

## 암호화의 기본 개념

### 대칭키 vs 비대칭키 암호화

**대칭키 암호화 (Symmetric Encryption)**

- 암호화와 복호화에 동일한 키를 사용
- 예시: AES, DES, 3DES, ChaCha20
- 장점: 빠른 처리 속도, 대용량 데이터에 적합
- 단점: 키 공유 문제 (키를 안전하게 전달하기 어려움)
- 사용 사례: 데이터베이스 암호화, 파일 암호화, 디스크 암호화

**비대칭키 암호화 (Asymmetric Encryption)**

- 공개키(암호화)와 개인키(복호화)를 쌍으로 사용
- 예시: RSA, ECC, DSA
- 장점: 키 배포 문제 해결, 디지털 서명 가능
- 단점: 느린 속도, 암호화 데이터 크기 제한
- 사용 사례: HTTPS 핸드셰이크, 전자서명, 인증서

**실무에서의 조합** 대부분의 보안 시스템은 두 방식을 함께 사용. HTTPS가 대표적인 예로, 초기 연결에서는 RSA/ECC로 대칭키를 안전하게 교환하고, 실제 데이터 전송에는 빠른 AES를 사용.

## AES: 현대 암호화의 표준

### AES란?

AES(Advanced Encryption Standard)는 2001년 미국 NIST가 공식 표준으로 채택한 대칭키 블록 암호화 알고리즘. 이전 표준인 DES를 대체하여 현재 가장 널리 사용됨.

**핵심 특징**

- 블록 크기: 128비트 고정
- 키 길이: 128, 192, 256비트 지원
- 치환-순열 네트워크(SPN) 구조
- 하드웨어 가속 지원 (AES-NI)

### AES-128 vs AES-192 vs AES-256

숫자는 키의 길이를 의미하며, 보안 강도와 성능에 영향을 줌.

**AES-128**

- 키 길이: 128비트 (16바이트)
- 가능한 키 조합: 2^128 ≈ 3.4 × 10^38
- 암호화 라운드: 10회
- 보안 수준: 현재 기술로 깨는데 수십억 년 소요
- 성능: 가장 빠름

**AES-192**

- 키 길이: 192비트 (24바이트)
- 가능한 키 조합: 2^192
- 암호화 라운드: 12회
- 보안 수준: 극도로 높음
- 사용: 드물게 사용됨 (128과 256 사이 애매한 위치)

**AES-256**

- 키 길이: 256비트 (32바이트)
- 가능한 키 조합: 2^256 ≈ 1.1 × 10^77
- 암호화 라운드: 14회
- 보안 수준: 군사급, 최상위 기밀
- 성능: AES-128 대비 약 20-40% 느림 (하지만 AES-NI 환경에서는 차이 미미)

### 실무에서의 선택 가이드

**AES-128을 선택하는 경우**

```
• 일반 웹 서비스, 모바일 앱
• IoT 기기, 임베디드 시스템
• 실시간 스트리밍 서비스
• 성능이 중요한 환경
• 보안 규제가 엄격하지 않은 경우
```

**AES-256을 선택하는 경우**

```
• 금융 데이터 (거래 내역, 계좌 정보)
• 의료 정보 (환자 기록, 진료 정보)
• 개인 식별 정보 (주민등록번호, 여권 정보)
• 장기 보관 데이터 (10년 이상)
• 규제 준수 필요 (PCI-DSS, HIPAA, GDPR)
• 양자 컴퓨터 대비
```

**오해하지 말아야 할 점**

- AES-128도 현재 기술로는 사실상 깨지지 않음
- "128은 약하다"는 잘못된 인식이 있지만, 수학적으로 충분히 안전
- 대부분의 보안 침해는 암호 알고리즘의 약점이 아닌, 구현 오류나 키 관리 실수로 발생

## 해시 함수: SHA-256, SHA-512

해시 함수는 암호화가 아님. 단방향 함수로, 복호화가 불가능.

### SHA (Secure Hash Algorithm) 개념

**특징**

- 입력 데이터 → 고정 길이 해시값 출력
- 복호화 불가능 (단방향)
- 동일 입력 → 항상 동일 출력
- 미세한 입력 변화 → 완전히 다른 출력 (눈사태 효과)

### SHA-256 vs SHA-512

**SHA-256**

- 출력: 256비트 (32바이트)
- 16진수 표현: 64자
- 보안 강도: 2^128 (생일 공격 고려)
- 사용 사례: 비트코인, 인증서, 파일 무결성

**SHA-512**

- 출력: 512비트 (64바이트)
- 16진수 표현: 128자
- 보안 강도: 2^256
- 사용 사례: 초고도 보안이 필요한 경우

### 실제 사용 예시

**비밀번호 저장 (잘못된 방법)**

```
X SHA-256(password) 직접 해싱
→ 레인보우 테이블 공격에 취약
```

**비밀번호 저장 (올바른 방법)**

```
bcrypt, scrypt, Argon2 사용
→ Salt + 반복 연산으로 무차별 대입 방어
```

**파일 무결성 검증**

```
다운로드 파일의 SHA-256 체크섬 확인
원본: a3f5b1c2...
다운로드: a3f5b1c2... → 일치, 안전
```

**디지털 서명**

```
1. 문서의 SHA-256 해시 생성
2. 개인키로 해시 암호화
3. 수신자가 공개키로 검증
```

## 암호화 모드: 블록 암호를 실전에 사용

AES는 128비트(16바이트) 블록 단위로 암호화합니다. 하지만 실제 데이터는 수 KB에서 수 GB까지 다양합니다. 여러 블록을 어떻게 처리할지 정의하는 것이 암호화 모드입니다.

### ECB (Electronic Codebook) - 사용 금지

**동작 방식**

- 각 블록을 독립적으로 암호화
- 동일 평문 블록 → 동일 암호문 블록

**문제점**

```
X 패턴이 그대로 드러남
X 블록 재배치 공격 가능
X 실무에서 절대 사용 금지
```

**예시** 이미지를 ECB로 암호화하면 원본 이미지의 윤곽이 그대로 보입니다. 유명한 "ECB 펭귄" 사례를 검색해보세요.

### CBC (Cipher Block Chaining) - 전통적 방식

**동작 방식**

```
C1 = E(P1 ⊕ IV)
C2 = E(P2 ⊕ C1)
C3 = E(P3 ⊕ C2)
```

**특징**

- IV (Initialization Vector) 필요: 랜덤 16바이트
- 각 블록이 이전 블록에 의존
- 암호화는 순차적, 복호화는 병렬 가능

**장점**

- 널리 검증된 방식
- 하드웨어 지원 우수
- 구현이 비교적 단순

**단점**

- 암호화 시 병렬 처리 불가
- 패딩 필요 (PKCS#7)
- 패딩 오라클 공격 위험
- 무결성 보장 없음 (별도 HMAC 필요)

**사용 사례**

```
• 파일 암호화 (ZIP, 7z)
• 디스크 암호화 (LUKS)
• 레거시 시스템 호환
• TLS 1.2 이하 (TLS_RSA_WITH_AES_128_CBC_SHA)
```

### CTR (Counter Mode) - 스트림 암호처럼

**동작 방식**

```
C1 = P1 ⊕ E(Nonce || Counter1)
C2 = P2 ⊕ E(Nonce || Counter2)
C3 = P3 ⊕ E(Nonce || Counter3)
```

**특징**

- 블록 암호를 스트림 암호처럼 사용
- Nonce + Counter 조합
- 완전 병렬 처리 가능
- 패딩 불필요

**장점**

- 암호화/복호화 모두 병렬 가능
- 랜덤 액세스 가능 (특정 위치만 복호화)
- 패딩 공격 면역
- 성능이 매우 좋음

**단점**

- Nonce 재사용 시 치명적 (키스트림 노출)
- 무결성 보장 없음

**사용 사례**

```
• 디스크 암호화 (특정 섹터만 읽기)
• VPN (IPsec)
• SSH
```

### GCM (Galois/Counter Mode) - 현대적 표준

**동작 방식**

- CTR 모드로 암호화
- GMAC으로 인증 태그 생성
- AEAD (Authenticated Encryption with Associated Data)

**특징**

```
입력:
  • 평문
  • AAD (Additional Authenticated Data): 암호화하지 않지만 인증할 데이터
  • Nonce (12바이트 권장)
  
출력:
  • 암호문
  • 인증 태그 (16바이트): 무결성 검증용
```

**장점**

- 암호화 + 인증을 한 번에
- 완전 병렬 처리 가능
- 뛰어난 성능 (하드웨어 가속)
- 패딩 불필요
- AAD로 메타데이터 보호 가능

**단점**

- Nonce 재사용 시 치명적
- 구현이 복잡함

**사용 사례**

```
• TLS 1.3 (기본 모드)
• QUIC, HTTP/3
• WPA3 (Wi-Fi 보안)
• IPsec
• 클라우드 스토리지 암호화
• 현대 API 통신
```

**실제 예시: HTTPS**

```
TLS_AES_128_GCM_SHA256

해석:
• TLS 프로토콜
• AES-128 암호화
• GCM 모드
• SHA-256 해시 (핸드셰이크용)
```

### 모드 선택 가이드

**신규 프로젝트**

```
1순위: GCM (인증 + 암호화)
2순위: CTR + HMAC (별도 인증)
3순위: CBC + HMAC (레거시 호환)
```

**레거시 시스템**

```
CBC: 호환성 필요 시
주의: 반드시 HMAC 추가
```

**특수 요구사항**

```
랜덤 액세스: CTR, GCM
스트리밍: CTR, GCM
초고속: GCM (하드웨어 가속)
```

## 실전 예시: 데이터베이스 민감 정보 암호화

### 시나리오

사용자의 주민등록번호, 신용카드 번호를 데이터베이스에 저장해야 합니다.

### 암호화 설계

**1. 알고리즘 선택**

```
AES-256-GCM
• AES-256: 규제 준수 (금융, 개인정보보호법)
• GCM: 무결성 보장, 변조 방지
```

**2. 키 관리**

```
X 잘못된 방법: 코드에 하드코딩
X 잘못된 방법: 설정 파일에 평문 저장

올바른 방법:
• AWS KMS, Azure Key Vault 사용
• HSM (Hardware Security Module)
• 키 회전 정책 (1년마다)
• 개발/운영 환경 키 분리
```

**3. 구현 패턴**

```python
def encrypt_sensitive_data(plaintext):
    # 1. KMS에서 DEK (Data Encryption Key) 획득
    dek = kms_client.get_data_key()
    
    # 2. 랜덤 Nonce 생성 (12바이트)
    nonce = os.urandom(12)
    
    # 3. AES-256-GCM 암호화
    cipher = AES.new(dek, AES.MODE_GCM, nonce=nonce)
    ciphertext, tag = cipher.encrypt_and_digest(plaintext.encode())
    
    # 4. Nonce + Tag + Ciphertext 결합
    encrypted = nonce + tag + ciphertext
    
    # 5. Base64 인코딩 (DB 저장용)
    return base64.b64encode(encrypted).decode()

def decrypt_sensitive_data(encrypted):
    # 1. Base64 디코딩
    data = base64.b64decode(encrypted)
    
    # 2. 구성 요소 분리
    nonce = data[:12]
    tag = data[12:28]
    ciphertext = data[28:]
    
    # 3. KMS에서 DEK 획득
    dek = kms_client.get_data_key()
    
    # 4. 복호화 + 무결성 검증
    cipher = AES.new(dek, AES.MODE_GCM, nonce=nonce)
    plaintext = cipher.decrypt_and_verify(ciphertext, tag)
    
    return plaintext.decode()
```

## 흔한 실수와 해결법

### 실수 1: ECB 모드 사용

```
X AES-128-ECB
o AES-128-GCM 또는 AES-128-CBC
```

### 실수 2: 고정된 IV/Nonce 사용

```
x iv = b'1234567890123456'  # 항상 동일
o iv = os.urandom(16)        # 매번 새로 생성
```

### 실수 3: 인증 없는 암호화

```
X AES-CBC만 사용
o AES-GCM (인증 포함)
o AES-CBC + HMAC-SHA256
```

### 실수 4: 비밀번호를 직접 키로 사용

```
X key = password.encode()
o key = PBKDF2(password, salt, iterations=100000)
```

### 실수 5: 약한 난수 생성기 사용

```
x import random; key = random.randbytes(32)
o import os; key = os.urandom(32)
o import secrets; key = secrets.token_bytes(32)
```

## 성능 최적화 팁

### 하드웨어 가속 활용

```
• CPU의 AES-NI 명령어 확인
• 최신 암호화 라이브러리 사용 (OpenSSL 3.0+)
• GCM의 경우 PCLMULQDQ 명령어 활용
```

### 대용량 데이터 처리

```
• 스트리밍 암호화 (메모리 효율)
• 청크 단위 처리 (64KB - 1MB)
• 병렬 처리 가능 모드 선택 (GCM, CTR)
```

### 벤치마크 예시 (AES-NI 환경)

```
AES-128-GCM: ~3 GB/s
AES-256-GCM: ~2.5 GB/s
AES-128-CBC: ~1.5 GB/s
AES-256-CBC: ~1.2 GB/s
```

## 규제 준수 체크리스트

### GDPR (유럽 개인정보보호법)

```
최소 AES-128 이상
전송 중 암호화 (TLS 1.2+)
저장 시 암호화
키 관리 정책 문서화
```

### PCI-DSS (신용카드 정보)

```
AES-256 권장
키 회전 정책
접근 로그 관리
정기 보안 감사
```

### HIPAA (미국 의료정보)

```
AES-256
접근 제어
암호화된 백업
감사 추적
```

## 요약

- 대칭키 암호화: AES-128-GCM (일반), AES-256-GCM (고보안)
- 해시: SHA-256 (범용), bcrypt/Argon2 (비밀번호)
- 모드: GCM > CTR+HMAC > CBC+HMAC
- 키 관리: KMS 사용, 절대 하드코딩 금지
