---
title: 필수 지식
date: 2025-12-04
tags:
  - it
  - CS
  - 필수지식
---
# CS 필수 지식 정리
## 1. 컴퓨터 구조 (Computer Architecture)

### 컴퓨터 구조의 2 그룹

**컴퓨터의 구조:**

- 데이터 영역과 명령어 영역의 분리
- 컴퓨터의 이해를 위한 정보

**컴퓨터의 핵심 부품:**

- CPU: 메모리와 캐시 메모리, 보조기억장치, 입출력장치
- ALU (산술논리장치): 산술 연산과 논리 연산 수행
- 제어장치: 명령어 해석 및 제어 신호 생성
- 레지스터: CPU 내부의 고속 저장 공간

### 핵심 개념

- **명령어 사이클**: Fetch → Decode → Execute → Store
- **파이프라이닝**: 명령어를 여러 단계로 나눠 동시 처리
- **파이프라인 해저드**: 구조적, 데이터, 제어 해저드
- **캐시 메모리**: L1, L2, L3 캐시의 계층 구조
- **지역성 원리**:
    - 시간적 지역성: 최근 접근한 데이터에 다시 접근
    - 공간적 지역성: 접근한 데이터 근처의 데이터에 접근
- **메모리 계층**: 레지스터 → 캐시 → RAM → HDD/SSD
- **병렬 처리**: 멀티코어, SIMD, MIMD
- **부동 소수점 표현**: IEEE 754 표준

## 2. 운영체제 (Operating System)

### 운영체제의 2 그룹

**프로세스 및 스레드 관리:**

- 프로세스와 스레드의 개념과 차이
- 동기화 문제 해결

**자원 할당 및 관리:**

- CPU 관리 (CPU 스케줄링)
- 메모리 관리 (가상 메모리 시스템)
- 파일/디렉터리 관리, 파일 시스템

### 프로세스와 스레드

**프로세스:**

- 실행 중인 프로그램의 인스턴스
- 독립적인 메모리 공간 (코드, 데이터, 스택, 힙)
- Context Switching 비용이 큼

**스레드:**

- 프로세스 내의 실행 단위
- 스택만 독립적, 나머지는 공유
- 가벼운 Context Switching

### CPU 스케줄링

- **FCFS** (First Come First Served): 먼저 온 순서대로
- **SJF** (Shortest Job First): 실행 시간이 짧은 것부터
- **Round Robin**: 시간 할당량(Time Quantum)만큼 순환
- **Priority Scheduling**: 우선순위 기반
- **Multilevel Queue**: 여러 큐로 프로세스 분류

### 동기화 (Synchronization)

- **Race Condition**: 여러 프로세스가 동시에 공유 자원 접근
- **Critical Section**: 공유 자원에 접근하는 코드 영역
- **뮤텍스(Mutex)**: 1개의 스레드만 접근 가능한 Lock
- **세마포어(Semaphore)**: N개의 스레드 접근 허용
- **모니터(Monitor)**: 고수준 동기화 도구

### 교착상태 (Deadlock)

**발생 조건 4가지:**

1. **상호 배제** (Mutual Exclusion): 자원은 한 번에 하나의 프로세스만
2. **점유와 대기** (Hold and Wait): 자원을 가진 채 다른 자원 대기
3. **비선점** (No Preemption): 강제로 자원 빼앗기 불가
4. **순환 대기** (Circular Wait): 프로세스들이 원형으로 자원 대기

**해결 방법:**

- 예방(Prevention): 4가지 조건 중 하나를 제거
- 회피(Avoidance): 은행원 알고리즘
- 탐지 및 회복(Detection & Recovery)
- 무시(Ignore): 타조 알고리즘

### 메모리 관리

- **페이징(Paging)**: 고정 크기 페이지로 분할
- **세그먼테이션(Segmentation)**: 가변 크기 세그먼트로 분할
- **가상 메모리**: 물리 메모리보다 큰 프로그램 실행 가능
- **페이지 교체 알고리즘**:
    - FIFO: 먼저 들어온 페이지 교체
    - LRU: 가장 오래 사용 안 한 페이지 교체
    - LFU: 참조 횟수가 가장 적은 페이지 교체
    - Optimal: 미래에 가장 오래 사용 안 할 페이지 교체

## 3. 자료구조 (Data Structure)

### 자료구조의 2 그룹

**자료구조의 큰 그림:**

- 배열과 연결 리스트
- 스택과 큐
- 해시 테이블
- 트리
- 그래프

**주요 자료구조:**

- 핵심 내용들

### 선형 자료구조

**배열 (Array):**

- 연속된 메모리 공간
- 접근: O(1), 삽입/삭제: O(n)
- 인덱스로 빠른 접근 가능

**연결 리스트 (Linked List):**

- 노드들이 포인터로 연결
- 접근: O(n), 삽입/삭제: O(1)
- 동적 크기 조절 가능
- 종류: 단일, 이중, 원형 연결 리스트

**스택 (Stack):**

- LIFO (Last In First Out)
- push, pop, peek 연산
- 활용: 함수 호출, 괄호 검사, 후위 표기법

**큐 (Queue):**

- FIFO (First In First Out)
- enqueue, dequeue 연산
- 활용: BFS, 프린터 대기열, 프로세스 스케줄링

**덱 (Deque):**

- 양쪽에서 삽입/삭제 가능

### 비선형 자료구조

**트리 (Tree):**

- 계층적 구조
- 노드와 간선으로 구성
- 용어: 루트, 부모, 자식, 리프, 높이, 깊이

**이진 트리 (Binary Tree):**

- 각 노드가 최대 2개의 자식
- 종류: 완전, 포화, 편향 이진 트리

**이진 탐색 트리 (BST):**

- 왼쪽 < 부모 < 오른쪽 규칙
- 평균: O(log n), 최악: O(n)
- 편향 시 성능 저하

**균형 트리:**

- **AVL 트리**: 높이 차이 1 이하 유지
- **Red-Black 트리**: 색깔로 균형 유지
- **B-트리**: 데이터베이스 인덱스에 사용

**힙 (Heap):**

- 완전 이진 트리
- 최대 힙: 부모 ≥ 자식
- 최소 힙: 부모 ≤ 자식
- 우선순위 큐 구현에 사용

**그래프 (Graph):**

- 정점(Vertex)과 간선(Edge)
- 방향/무방향, 가중치/비가중치
- 표현: 인접 행렬, 인접 리스트

### 해시 테이블 (Hash Table)

- 키-값 쌍으로 저장
- 해시 함수로 인덱스 계산
- 평균 O(1), 최악 O(n)

**충돌 해결:**

- 체이닝: 연결 리스트로 연결
- 개방 주소법: 선형 조사, 제곱 조사, 이중 해싱

## 4. 네트워크 (Network)

### 네트워크의 2 그룹

**네트워크의 큰 그림:**

- 물리 계층 (데이터 링크 계층과 겹치는 장비)
- 네트워크 계층 (IP)
- 전송 계층 (TCP/UDP)
- 응용 계층 (HTTP와 HTTPS)

**프로토콜 및 인터넷 트래픽:**

- 프로토콜 상세 내용

### OSI 7계층 vs TCP/IP 4계층

**OSI 7계층:**

1. **물리 계층**: 비트 전송, 케이블, 허브
2. **데이터 링크 계층**: 프레임, MAC 주소, 스위치
3. **네트워크 계층**: IP, 라우팅, 라우터
4. **전송 계층**: TCP, UDP, 포트
5. **세션 계층**: 세션 연결/종료
6. **표현 계층**: 암호화, 압축, 인코딩
7. **응용 계층**: HTTP, FTP, DNS, SMTP

**TCP/IP 4계층:**

1. 네트워크 인터페이스 계층
2. 인터넷 계층
3. 전송 계층
4. 응용 계층

### 전송 계층 프로토콜

**TCP (Transmission Control Protocol):**

- 연결 지향적
- 신뢰성 보장 (재전송, 순서 보장)
- 흐름 제어, 혼잡 제어
- 3-way handshake (연결), 4-way handshake (종료)
- 사용: HTTP, HTTPS, FTP, SMTP

**UDP (User Datagram Protocol):**

- 비연결 지향적
- 신뢰성 없음 (빠른 속도)
- 실시간 스트리밍에 적합
- 사용: DNS, 동영상 스트리밍, 게임

### 3-way Handshake

1. **SYN**: 클라이언트 → 서버 (연결 요청)
2. **SYN + ACK**: 서버 → 클라이언트 (요청 수락)
3. **ACK**: 클라이언트 → 서버 (연결 확립)

### 4-way Handshake (연결 종료)

1. **FIN**: 클라이언트 → 서버 (종료 요청)
2. **ACK**: 서버 → 클라이언트 (종료 수락)
3. **FIN**: 서버 → 클라이언트 (종료 준비 완료)
4. **ACK**: 클라이언트 → 서버 (완전 종료)

### 응용 계층 프로토콜

**HTTP (HyperText Transfer Protocol):**

- 상태 없는(Stateless) 프로토콜
- 메서드: GET, POST, PUT, DELETE, PATCH
- 상태 코드:
    - 2xx: 성공 (200 OK, 201 Created)
    - 3xx: 리다이렉션 (301, 302)
    - 4xx: 클라이언트 오류 (400, 401, 403, 404)
    - 5xx: 서버 오류 (500, 502, 503)

**HTTPS:**

- HTTP + SSL/TLS 암호화
- 포트 443 사용
- 공개키 암호화로 데이터 보호

**DNS (Domain Name System):**

- 도메인 이름을 IP 주소로 변환
- 계층 구조: 루트 DNS → TLD DNS → 권한 DNS

**기타 프로토콜:**

- **FTP**: 파일 전송
- **SMTP**: 이메일 전송
- **POP3/IMAP**: 이메일 수신

### 네트워크 주요 개념

**IP 주소:**

- IPv4: 32비트 (예: 192.168.0.1)
- IPv6: 128비트 (주소 고갈 문제 해결)
- 공인 IP vs 사설 IP

**NAT (Network Address Translation):**

- 사설 IP를 공인 IP로 변환
- IP 주소 절약

**서브넷 마스크:**

- 네트워크 부분과 호스트 부분 구분

**라우팅:**

- 최적 경로 선택
- 정적 라우팅 vs 동적 라우팅

**로드 밸런싱:**

- 트래픽을 여러 서버에 분산
- 알고리즘: Round Robin, Least Connection, IP Hash

**CDN (Content Delivery Network):**

- 콘텐츠를 지리적으로 분산 저장
- 빠른 응답 속도

## 5. 데이터베이스 (Database)

### 데이터베이스의 2 그룹

**데이터베이스의 큰 그림:**

- 데이터베이스와 DBMS
- 데이터베이스 vs 파일 시스템
- 엔티티와 스키마
- 트랜잭션과 ACID

**RDBMS와 기본:**

- RDBMS와 SQL
- 정규화와 쿼리
- 데이터베이스 설계

**NoSQL:**

- NoSQL의 특징
- 다양한 NoSQL(MongoDB, Redis)

### DBMS (Database Management System)

- 데이터베이스를 관리하는 소프트웨어
- 데이터 독립성, 무결성, 보안성, 동시성 제어

### 관계형 데이터베이스 (RDBMS)

**주요 제품:**

- MySQL, PostgreSQL, Oracle, MS SQL Server, MariaDB

**특징:**

- 테이블(릴레이션) 기반
- SQL로 데이터 조작
- 스키마 정의 필요
- ACID 속성 보장

### SQL (Structured Query Language)

**DDL (Data Definition Language):**

- CREATE, ALTER, DROP, TRUNCATE

**DML (Data Manipulation Language):**

- SELECT, INSERT, UPDATE, DELETE

**DCL (Data Control Language):**

- GRANT, REVOKE

**TCL (Transaction Control Language):**

- COMMIT, ROLLBACK, SAVEPOINT

**주요 쿼리:**

```sql
-- 조인
SELECT * FROM A INNER JOIN B ON A.id = B.id;

-- 그룹화
SELECT category, COUNT(*) FROM products GROUP BY category;

-- 서브쿼리
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);

-- 집계 함수
SELECT AVG(price), MAX(price), MIN(price) FROM products;
```

### JOIN 종류

- **INNER JOIN**: 양쪽 모두 있는 데이터
- **LEFT JOIN**: 왼쪽 테이블의 모든 데이터
- **RIGHT JOIN**: 오른쪽 테이블의 모든 데이터
- **FULL OUTER JOIN**: 양쪽의 모든 데이터

### 정규화 (Normalization)

**목적:**

- 데이터 중복 제거
- 이상 현상 방지 (삽입, 갱신, 삭제 이상)

**정규화 단계:**

- **1NF**: 원자값만 포함 (더 이상 쪼갤 수 없는 값)
- **2NF**: 부분 함수 종속 제거 (완전 함수 종속)
- **3NF**: 이행적 함수 종속 제거
- **BCNF**: 모든 결정자가 후보키

**반정규화:**

- 성능 향상을 위해 의도적으로 중복 허용

### 트랜잭션 (Transaction)

**정의:**

- 데이터베이스의 논리적 작업 단위
- 모두 성공하거나 모두 실패

**ACID 속성:**

1. **원자성 (Atomicity)**: All or Nothing
2. **일관성 (Consistency)**: 규칙 유지
3. **고립성 (Isolation)**: 독립적 실행
4. **지속성 (Durability)**: 영구 반영

**격리 수준 (Isolation Level):**

1. **Read Uncommitted**: 커밋 안 된 데이터 읽기 가능 (Dirty Read)
2. **Read Committed**: 커밋된 데이터만 읽기
3. **Repeatable Read**: 같은 데이터를 항상 같게 읽음
4. **Serializable**: 완전한 격리 (성능 저하)

### 인덱스 (Index)

**목적:**

- 검색 속도 향상 (B-Tree 구조 사용)

**장점:**

- SELECT 속도 향상
- ORDER BY, GROUP BY 성능 개선

**단점:**

- INSERT, UPDATE, DELETE 느려짐
- 추가 저장 공간 필요

**종류:**

- 클러스터형 인덱스: 물리적 정렬
- 비클러스터형 인덱스: 별도의 인덱스 테이블

### NoSQL (Not Only SQL)

**특징:**

- 유연한 스키마
- 수평 확장(Scale-out) 용이
- 대용량 데이터 처리
- 고가용성

**종류:**

- **Key-Value**: Redis, DynamoDB
- **Document**: MongoDB, CouchDB
- **Column-Family**: Cassandra, HBase
- **Graph**: Neo4j

**MongoDB:**

- JSON 형태의 문서 저장
- 스키마 자유로움
- 복제와 샤딩 지원

**Redis:**

- 인메모리 데이터베이스
- 캐싱에 주로 사용
- 다양한 자료구조 지원 (String, List, Set, Hash)

### RDBMS vs NoSQL

|구분|RDBMS|NoSQL|
|---|---|---|
|데이터 모델|테이블 (관계형)|다양 (문서, 키-값 등)|
|스키마|고정적|유연함|
|확장|수직 확장 (Scale-up)|수평 확장 (Scale-out)|
|트랜잭션|강력한 ACID|최종 일관성 (BASE)|
|사용 사례|금융, 회계, ERP|실시간 웹, 빅데이터|

## 6. 알고리즘 (Algorithm)

### 시간 복잡도

- **O(1)**: 상수 시간 (해시 테이블 접근)
- **O(log n)**: 로그 시간 (이진 탐색)
- **O(n)**: 선형 시간 (순차 탐색)
- **O(n log n)**: 선형 로그 (병합 정렬, 퀵 정렬)
- **O(n²)**: 이차 시간 (버블 정렬, 선택 정렬)
- **O(2ⁿ)**: 지수 시간 (피보나치 재귀)
- **O(n!)**: 팩토리얼 시간 (순열)

### 정렬 알고리즘

**버블 정렬 (Bubble Sort):**

- 인접한 원소 비교 및 교환
- 시간: O(n²), 공간: O(1)
- 안정 정렬

**선택 정렬 (Selection Sort):**

- 최솟값을 찾아 앞으로 이동
- 시간: O(n²), 공간: O(1)
- 불안정 정렬

**삽입 정렬 (Insertion Sort):**

- 정렬된 부분에 삽입
- 시간: O(n²), 공간: O(1)
- 안정 정렬, 거의 정렬된 데이터에 효율적

**병합 정렬 (Merge Sort):**

- 분할 정복 방식
- 시간: O(n log n), 공간: O(n)
- 안정 정렬

**퀵 정렬 (Quick Sort):**

- 피벗 기준으로 분할
- 평균: O(n log n), 최악: O(n²), 공간: O(log n)
- 불안정 정렬, 실전에서 가장 빠름

**힙 정렬 (Heap Sort):**

- 힙 자료구조 이용
- 시간: O(n log n), 공간: O(1)
- 불안정 정렬

### 탐색 알고리즘

**선형 탐색:**

- 순차적으로 검색
- 시간: O(n)

**이진 탐색 (Binary Search):**

- 정렬된 배열에서 중간값과 비교
- 시간: O(log n)
- 반드시 정렬된 상태여야 함

**DFS (Depth-First Search):**

- 깊이 우선 탐색
- 스택 또는 재귀로 구현
- 모든 경로 탐색

**BFS (Breadth-First Search):**

- 너비 우선 탐색
- 큐로 구현
- 최단 경로 찾기

### 동적 프로그래밍 (Dynamic Programming)

**특징:**

- 큰 문제를 작은 문제로 분할
- 중복 계산 방지 (메모이제이션)
- 최적 부분 구조

**대표 문제:**

- 피보나치 수열
- 배낭 문제 (Knapsack)
- 최장 공통 부분 수열 (LCS)
- 최단 경로 (플로이드-워셜)

### 그리디 알고리즘

**특징:**

- 매 순간 최선의 선택
- 최적해 보장 안 됨

**대표 문제:**

- 동전 거스름돈
- 회의실 배정
- 다익스트라 알고리즘

### 그래프 알고리즘

**다익스트라 (Dijkstra):**

- 단일 시작점 최단 경로
- 음수 가중치 불가
- 시간: O(E log V)

**벨만-포드 (Bellman-Ford):**

- 음수 가중치 가능
- 시간: O(VE)

**플로이드-워셜 (Floyd-Warshall):**

- 모든 쌍 최단 경로
- 시간: O(V³)

**크루스칼 (Kruskal):**

- 최소 신장 트리 (MST)
- 간선 기준, Union-Find 사용

**프림 (Prim):**

- 최소 신장 트리 (MST)
- 정점 기준, 우선순위 큐 사용

**위상 정렬 (Topological Sort):**

- DAG(방향 비순환 그래프)에서 순서 결정

## 7. 소프트웨어 공학

### 객체지향 프로그래밍 (OOP)

**4대 특징:**

1. **캡슐화 (Encapsulation)**
    
    - 데이터와 메서드를 하나로 묶음
    - 정보 은닉 (private, protected, public)
2. **상속 (Inheritance)**
    
    - 부모 클래스의 속성과 메서드를 물려받음
    - 코드 재사용성
3. **다형성 (Polymorphism)**
    
    - 오버로딩: 같은 이름, 다른 매개변수
    - 오버라이딩: 부모 메서드 재정의
    - 인터페이스와 추상 클래스
4. **추상화 (Abstraction)**
    
    - 공통된 특징 추출
    - 불필요한 세부사항 숨김

### SOLID 원칙

1. **SRP (Single Responsibility Principle)**
    
    - 단일 책임 원칙
    - 클래스는 하나의 책임만
2. **OCP (Open-Closed Principle)**
    
    - 개방-폐쇄 원칙
    - 확장에는 열려있고, 수정에는 닫혀있음
3. **LSP (Liskov Substitution Principle)**
    
    - 리스코프 치환 원칙
    - 자식 클래스는 부모 클래스를 대체 가능
4. **ISP (Interface Segregation Principle)**
    
    - 인터페이스 분리 원칙
    - 클라이언트는 사용하지 않는 인터페이스에 의존하지 않음
5. **DIP (Dependency Inversion Principle)**
    
    - 의존 역전 원칙
    - 구체화가 아닌 추상화에 의존

### 디자인 패턴

**생성 패턴:**

- **Singleton**: 인스턴스 1개만 생성
- **Factory**: 객체 생성 로직 분리
- **Builder**: 복잡한 객체 단계적 생성
- **Prototype**: 객체 복제

**구조 패턴:**

- **Adapter**: 인터페이스 변환
- **Decorator**: 기능 동적 추가
- **Proxy**: 대리자 역할
- **Facade**: 복잡한 시스템을 간단하게

**행위 패턴:**

- **Observer**: 상태 변화 자동 통보
- **Strategy**: 알고리즘 캡슐화
- **Template Method**: 알고리즘 구조 정의
- **Command**: 요청을 객체로 캡슐화

### 개발 방법론

**애자일 (Agile):**

- 반복적 개발
- 스크럼, 칸반

**TDD (Test-Driven Development):**

1. 테스트 작성
2. 코드 작성
3. 리팩토링

**CI/CD:**

- Continuous Integration: 지속적 통합
- Continuous Deployment: 지속적 배포
- 자동화된 빌드와 테스트

### 버전 관리 (Git)

**기본 명령어:**

- git init, clone, add, commit, push, pull
- git branch, checkout, merge

**브랜치 전략:**

- Git Flow: master, develop, feature, release, hotfix
- GitHub Flow: master + feature 브랜치

**협업:**

- Pull Request (PR)
- Code Review
- 충돌 해결 (Conflict Resolution)

## 8. 보안 (Security)

### 암호화

**대칭키 암호화:**

- 암호화와 복호화에 같은 키 사용
- 빠르지만 키 관리 어려움
- 예: AES, DES

**공개키 암호화 (비대칭키):**

- 공개키로 암호화, 개인키로 복호화
- 느리지만 안전한 키 교환
- 예: RSA

**해싱 (Hashing):**

- 단방향 암호화 (복호화 불가)
- 고정된 길이의 해시값 생성
- 예: SHA-256, MD5
- 용도: 비밀번호 저장, 무결성 검증

**솔트 (Salt):**

- 해시 전에 랜덤 값 추가
- 레인보우 테이블 공격 방지
- 같은 비밀번호도 다른 해시값 생성

### 인증 (Authentication) vs 인가 (Authorization)

**인증 (Authentication):**

- "당신이 누구인가?"를 확인
- 로그인, 생체 인식, OTP

**인가 (Authorization):**

- "당신이 무엇을 할 수 있는가?"를 확인
- 권한, 역할 기반 접근 제어 (RBAC)

### 세션 (Session) vs 쿠키 (Cookie)

**쿠키:**

- 클라이언트(브라우저)에 저장
- Key-Value 형태
- 만료 시간 설정 가능
- 보안 취약 (XSS 공격 위험)

**세션:**

- 서버에 저장
- 세션 ID만 쿠키에 저장
- 더 안전하지만 서버 부담 증가
- 서버 확장 시 세션 공유 필요

**세션 vs 쿠키 차이:**

- 저장 위치: 서버 vs 클라이언트
- 보안: 세션이 더 안전
- 속도: 쿠키가 더 빠름
- 용량: 세션이 더 많이 저장 가능

### 토큰 기반 인증

**JWT (JSON Web Token):**

- Header.Payload.Signature 구조
- Stateless (서버에 상태 저장 안 함)
- 확장성 좋음 (MSA에 적합)
- 탈취 시 강제 만료 어려움

**구성:**

- Header: 알고리즘, 토큰 타입
- Payload: 사용자 정보, 만료 시간
- Signature: 검증용 서명

**Access Token + Refresh Token:**

- Access Token: 짧은 만료 시간 (15분~1시간)
- Refresh Token: 긴 만료 시간 (2주~1개월)
- Access Token 만료 시 Refresh Token으로 재발급

### OAuth 2.0

**목적:**

- 제3자 인증 (구글, 네이버, 카카오 로그인)
- 비밀번호 공유 없이 권한 위임

**흐름:**

1. 사용자가 제3자 서비스 로그인 요청
2. 인증 서버로 리다이렉트
3. 사용자 로그인 및 권한 승인
4. Authorization Code 발급
5. Code로 Access Token 요청
6. Access Token으로 리소스 접근

**역할:**

- Resource Owner: 사용자
- Client: 우리 애플리케이션
- Authorization Server: 인증 서버 (구글, 카카오)
- Resource Server: 보호된 자원을 가진 서버

### 주요 보안 취약점

**SQL Injection:**

- SQL 쿼리에 악의적인 코드 삽입
- 방어: Prepared Statement, ORM 사용

```sql
-- 취약한 코드
SELECT * FROM users WHERE id = '$id';
-- $id에 "1 OR 1=1" 입력 시 모든 데이터 노출

-- 안전한 코드 (Prepared Statement)
SELECT * FROM users WHERE id = ?;
```

**XSS (Cross-Site Scripting):**

- 악성 스크립트를 웹 페이지에 삽입
- 방어: 입력값 검증, 이스케이프 처리, CSP

```html
<!-- 취약한 코드 -->
<div>{{userInput}}</div>
<!-- userInput에 <script>alert('XSS')</script> 삽입 가능 -->

<!-- 안전한 코드 -->
<div>{{escapeHtml(userInput)}}</div>
```

**CSRF (Cross-Site Request Forgery):**

- 사용자가 의도하지 않은 요청 실행
- 방어: CSRF Token, SameSite Cookie

**SSRF (Server-Side Request Forgery):**

- 서버가 공격자가 지정한 URL에 요청
- 방어: URL 화이트리스트, 내부 IP 차단

**DDoS (Distributed Denial of Service):**

- 대량의 트래픽으로 서버 마비
- 방어: CDN, Rate Limiting, 방화벽

**Brute Force Attack:**

- 무차별 대입 공격
- 방어: 로그인 시도 제한, CAPTCHA, 2FA

### HTTPS와 SSL/TLS

**HTTPS:**

- HTTP + SSL/TLS
- 데이터 암호화
- 중간자 공격(MITM) 방지

**SSL/TLS 동작 과정:**

1. 클라이언트 → 서버: Hello 메시지
2. 서버 → 클라이언트: 인증서 전송
3. 클라이언트: 인증서 검증
4. 대칭키 생성 및 교환 (공개키로 암호화)
5. 대칭키로 암호화 통신

### 보안 헤더

**CORS (Cross-Origin Resource Sharing):**

- 다른 도메인 간 리소스 공유 제어
- Access-Control-Allow-Origin 헤더

**CSP (Content Security Policy):**

- XSS 공격 방어
- 허용된 리소스만 로드

**HSTS (HTTP Strict Transport Security):**

- HTTPS만 사용하도록 강제

### 비밀번호 보안

**Best Practices:**

- 평문 저장 금지
- 해싱 + 솔트 사용 (bcrypt, scrypt, Argon2)
- 비밀번호 정책: 최소 길이, 복잡도
- 2FA (Two-Factor Authentication)

## 9. 시스템 설계 (System Design)

### 확장성 (Scalability)

**수직 확장 (Scale-Up):**

- 서버 사양 업그레이드 (CPU, RAM 증가)
- 한계가 명확함
- 비용이 기하급수적으로 증가

**수평 확장 (Scale-Out):**

- 서버 대수 증가
- 무한 확장 가능
- 로드 밸런서 필요

### 로드 밸런싱 (Load Balancing)

**목적:**

- 트래픽을 여러 서버에 분산
- 가용성과 성능 향상

**알고리즘:**

- Round Robin: 순차적으로 분배
- Least Connection: 연결 수가 적은 서버
- IP Hash: IP 주소 기반 분배
- Weighted: 서버 성능에 따라 가중치 부여

**종류:**

- L4 (Layer 4): IP, Port 기반
- L7 (Layer 7): HTTP 헤더, URL 기반

### 캐싱 (Caching)

**목적:**

- 자주 사용하는 데이터를 빠르게 접근
- DB 부하 감소

**레벨:**

- 클라이언트 캐시: 브라우저 캐시
- CDN 캐시: 정적 리소스 (이미지, CSS, JS)
- 애플리케이션 캐시: Redis, Memcached
- 데이터베이스 캐시: 쿼리 결과 캐싱

**전략:**

- Cache-Aside (Lazy Loading): 요청 시 캐시 확인 후 로드
- Write-Through: 데이터 쓸 때 캐시와 DB 동시 업데이트
- Write-Back: 캐시 먼저 쓰고 나중에 DB 반영
- Refresh-Ahead: 만료 전에 미리 갱신

**캐시 무효화:**

- TTL (Time To Live): 만료 시간 설정
- Cache Eviction: LRU, LFU로 제거

### CDN (Content Delivery Network)

**목적:**

- 콘텐츠를 지리적으로 분산
- 사용자와 가까운 서버에서 제공
- 빠른 응답 속도, 원본 서버 부하 감소

**사용 사례:**

- 이미지, 동영상, CSS, JS 파일
- 스트리밍 서비스

### 데이터베이스 확장

**읽기 복제 (Read Replica):**

- Master(쓰기) + Slave(읽기) 구조
- 읽기 부하 분산
- Master 장애 시 Slave가 승격

**샤딩 (Sharding):**

- 데이터를 여러 DB에 분산
- 수평 파티셔닝
- 방법: Range, Hash, Directory-based

**파티셔닝:**

- 수평 파티셔닝: 행 단위 분할 (샤딩)
- 수직 파티셔닝: 열 단위 분할

### 메시지 큐 (Message Queue)

**목적:**

- 비동기 처리
- 시스템 간 결합도 감소
- 부하 분산

**제품:**

- RabbitMQ, Kafka, AWS SQS, Redis Queue

**사용 사례:**

- 이메일 발송
- 이미지 처리
- 로그 수집
- 실시간 스트리밍

**Kafka 특징:**

- 높은 처리량
- 영속성 (디스크 저장)
- 메시지 재처리 가능
- Pub/Sub 모델

### 마이크로서비스 아키텍처 (MSA)

**특징:**

- 서비스별로 독립적 배포
- 각 서비스가 독립적인 DB
- 기술 스택 자유롭게 선택

**장점:**

- 확장성 좋음
- 장애 격리
- 개발 생산성

**단점:**

- 복잡도 증가
- 분산 트랜잭션 어려움
- 네트워크 레이턴시

**vs 모놀리식:**

- 모놀리식: 하나의 애플리케이션
- MSA: 여러 개의 작은 서비스

### API Gateway

**역할:**

- 단일 진입점
- 인증/인가
- Rate Limiting
- 로드 밸런싱
- 로깅/모니터링

### 서비스 디스커버리

**목적:**

- MSA 환경에서 서비스 위치 동적 관리
- 서비스 등록 및 조회

**도구:**

- Consul, Eureka, Zookeeper

### CAP 정리

**분산 시스템의 세 가지 속성:**

- **Consistency (일관성)**: 모든 노드가 같은 데이터
- **Availability (가용성)**: 항상 응답 가능
- **Partition Tolerance (분할 허용)**: 네트워크 분할 시에도 동작

**중요:** 3가지 중 2가지만 만족 가능

- CP: 일관성 + 분할 허용 (MongoDB, HBase)
- AP: 가용성 + 분할 허용 (Cassandra, DynamoDB)
- CA: 일관성 + 가용성 (RDBMS, 단일 서버)

### 고가용성 (High Availability)

**개념:**

- 시스템이 오랜 시간 정상 작동
- 99.9% (3 nines) ~ 99.999% (5 nines)

**방법:**

- 이중화 (Redundancy)
- 장애 조치 (Failover)
- Health Check
- 백업과 복구

### 모니터링과 로깅

**메트릭 (Metrics):**

- CPU, 메모리, 디스크 사용률
- 응답 시간, 처리량
- 에러율

**로그 (Logging):**

- 애플리케이션 로그
- 접근 로그
- 에러 로그

**APM (Application Performance Monitoring):**

- 성능 병목 지점 파악
- 도구: New Relic, Datadog, Prometheus + Grafana

**분산 추적 (Distributed Tracing):**

- MSA에서 요청 흐름 추적
- 도구: Jaeger, Zipkin

## 10. 컴파일러와 인터프리터

### 컴파일러 (Compiler)

**특징:**

- 소스 코드 전체를 기계어로 변환
- 실행 파일 생성
- 실행 속도 빠름
- 에러를 실행 전에 발견

**언어:**

- C, C++, Go, Rust

**단계:**

1. 어휘 분석 (Lexical Analysis)
2. 구문 분석 (Syntax Analysis)
3. 의미 분석 (Semantic Analysis)
4. 중간 코드 생성
5. 최적화
6. 코드 생성

### 인터프리터 (Interpreter)

**특징:**

- 소스 코드를 한 줄씩 실행
- 실행 파일 생성 안 함
- 실행 속도 느림
- 플랫폼 독립적

**언어:**

- Python, JavaScript, Ruby

### JIT 컴파일 (Just-In-Time Compilation)

**특징:**

- 실행 시점에 컴파일
- 컴파일러와 인터프리터의 장점 결합
- 자주 실행되는 코드 최적화

**사용:**

- Java (JVM), JavaScript (V8), C# (.NET)

## 11. 웹 개발

### 브라우저 동작 원리

**렌더링 과정:**

1. HTML 파싱 → DOM 트리 생성
2. CSS 파싱 → CSSOM 트리 생성
3. DOM + CSSOM → 렌더 트리 생성
4. 레이아웃 (Reflow): 위치와 크기 계산
5. 페인트 (Repaint): 픽셀로 그리기
6. 합성 (Composite): 레이어 합치기

**리플로우 (Reflow):**

- 레이아웃 재계산
- 비용이 큼
- 최소화 필요

**리페인트 (Repaint):**

- 시각적 속성 변경 (색상 등)
- 리플로우보다 비용 적음

### 크리티컬 렌더링 패스 (Critical Rendering Path)

**최적화:**

- CSS는 상단에 (head)
- JS는 하단에 (body 끝) 또는 async/defer
- 불필요한 리소스 제거
- 이미지 최적화 (lazy loading, WebP)

### CSR vs SSR vs SSG

**CSR (Client-Side Rendering):**

- 클라이언트에서 렌더링
- 초기 로딩 느림, 이후 빠름
- SEO 불리
- 예: React SPA

**SSR (Server-Side Rendering):**

- 서버에서 렌더링
- 초기 로딩 빠름
- SEO 유리
- 서버 부하 증가
- 예: Next.js

**SSG (Static Site Generation):**

- 빌드 시점에 정적 HTML 생성
- 가장 빠름
- SEO 최고
- 동적 콘텐츠 제한
- 예: Gatsby, Next.js SSG

### REST API

**특징:**

- Stateless
- 리소스 중심 설계
- HTTP 메서드 활용

**설계 원칙:**

- URI는 명사 사용 (`/users`, `/posts`)
- HTTP 메서드로 행위 표현
- 계층 구조 표현 (`/users/1/posts`)
- 버전 관리 (`/v1/users`)

**HTTP 메서드:**

- GET: 조회 (Safe, Idempotent)
- POST: 생성
- PUT: 전체 수정 (Idempotent)
- PATCH: 부분 수정
- DELETE: 삭제 (Idempotent)

**Idempotent (멱등성):**

- 여러 번 호출해도 결과가 같음
- GET, PUT, DELETE는 멱등성 보장
- POST는 멱등성 없음

### GraphQL

**특징:**

- 클라이언트가 필요한 데이터만 요청
- Over-fetching, Under-fetching 해결
- 단일 엔드포인트

**vs REST:**

- REST: 여러 엔드포인트, 고정된 응답
- GraphQL: 단일 엔드포인트, 유연한 응답

### WebSocket

**특징:**

- 양방향 실시간 통신
- HTTP보다 오버헤드 적음
- 연결 유지 (persistent connection)

**사용 사례:**

- 채팅
- 실시간 알림
- 주식 가격 업데이트
- 온라인 게임

## 12. 테스트

### 테스트 종류

**단위 테스트 (Unit Test):**

- 가장 작은 단위 (함수, 메서드)
- 빠르고 독립적
- 많은 수 작성

**통합 테스트 (Integration Test):**

- 여러 모듈 간 상호작용
- DB, API 연동 테스트

**E2E 테스트 (End-to-End Test):**

- 전체 시스템 흐름
- 사용자 시나리오 기반
- 느리고 유지보수 비용 큼

**테스트 피라미드:**

- 단위 테스트 (많음) > 통합 테스트 (중간) > E2E (적음)

### TDD (Test-Driven Development)

**사이클:**

1. Red: 실패하는 테스트 작성
2. Green: 테스트 통과하는 최소 코드 작성
3. Refactor: 코드 개선

**장점:**

- 버그 조기 발견
- 리팩토링 안전
- 문서 역할

**단점:**

- 초기 개발 속도 느림
- 학습 곡선

### 테스트 커버리지

**개념:**

- 코드가 테스트로 실행된 비율
- 높다고 무조건 좋은 것은 아님
- 중요한 로직 위주로 테스트

### 모킹 (Mocking)

**목적:**

- 외부 의존성 제거
- 테스트 독립성 확보

**도구:**

- Jest (JavaScript)
- Mockito (Java)
- unittest.mock (Python)

## 13. 성능 최적화

### 프론트엔드 최적화

**번들 크기 줄이기:**

- Code Splitting
- Tree Shaking
- Lazy Loading
- Minification

**이미지 최적화:**

- WebP, AVIF 포맷 사용
- 적절한 크기로 리사이즈
- Lazy Loading
- CDN 사용

**캐싱:**

- 브라우저 캐시 활용
- Service Worker
- Cache-Control 헤더

**렌더링 최적화:**

- Virtual DOM (React)
- Debounce, Throttle
- requestAnimationFrame
- CSS 애니메이션 사용 (transform, opacity)

### 백엔드 최적화

**데이터베이스:**

- 인덱스 최적화
- 쿼리 최적화 (N+1 문제 해결)
- 커넥션 풀링
- 읽기 복제

**API:**

- 페이지네이션
- 필드 선택 (GraphQL)
- 압축 (gzip, brotli)
- 캐싱 (Redis)

**비동기 처리:**

- 메시지 큐 활용
- 백그라운드 작업
- 병렬 처리

### 네트워크 최적화

**HTTP/2:**

- 멀티플렉싱
- 헤더 압축
- Server Push

**HTTP/3:**

- QUIC 프로토콜 (UDP 기반)
- 더 빠른 연결 설정
- 패킷 손실 개선

---

## 면접 준비 체크리스트

### 필수 암기 사항

- [ ] 프로세스 vs 스레드 차이
- [ ] TCP vs UDP 차이
- [ ] 3-way handshake 과정
- [ ] Deadlock 4가지 조건
- [ ] ACID 속성
- [ ] 정규화 단계와 목적
- [ ] 인덱스 장단점
- [ ] JOIN 종류
- [ ] OSI 7계층
- [ ] HTTP 상태 코드
- [ ] OOP 4대 특징
- [ ] SOLID 원칙
- [ ] 시간 복잡도 종류
- [ ] 정렬 알고리즘 특징
- [ ] DFS vs BFS
- [ ] 대칭키 vs 공개키
- [ ] 세션 vs 쿠키 vs JWT
- [ ] SQL Injection, XSS, CSRF
- [ ] CAP 정리
- [ ] 수평 확장 vs 수직 확장

### 실습 필수 항목

- [ ] 자료구조 직접 구현 (스택, 큐, 연결 리스트, 트리)
- [ ] 정렬/탐색 알고리즘 구현
- [ ] 간단한 OS 명령어 사용 (프로세스, 메모리 확인)
- [ ] SQL 쿼리 작성 (JOIN, GROUP BY, 서브쿼리)
- [ ] REST API 설계 및 구현
- [ ] Git 브랜치 전략 실습
- [ ] 디자인 패턴 구현 (Singleton, Factory, Observer)
- [ ] 간단한 시스템 설계

### 학습 순서 추천

1. **기초**: 자료구조 → 알고리즘
2. **심화**: 운영체제 → 네트워크 → 데이터베이스
3. **응용**: 컴퓨터 구조 → 보안 → 시스템 설계
4. **실전**: 소프트웨어 공학 → 웹 개발 → 테스트/최적화
