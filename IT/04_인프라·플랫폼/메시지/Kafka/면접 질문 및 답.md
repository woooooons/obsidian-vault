---
title: 면접 질문 및 답
date: 2026-01-07
tags:
  - 가이드
  - 인프라
  - 메시지
  - kafka
  - 면접
---
# Kafka Basic Interview Questions

## What is Apache Kafka?

Apache Kafka는 **대규모 분산 이벤트 스트리밍 플랫폼**이다.  
실시간으로 발생하는 데이터를 **높은 처리량, 낮은 지연, 내구성**을 보장하며 **발행(Publish)·저장(Store)·구독(Subscribe)** 할 수 있도록 설계되었다.  
로그 수집, 이벤트 처리, 마이크로서비스 간 비동기 통신에 주로 사용된다.

---

## Why do we use Kafka?

- 대용량 데이터 처리 (초당 수백만 메시지)
    
- 시스템 간 **느슨한 결합(Decoupling)**
    
- 장애 발생 시에도 데이터 유실 방지
    
- 실시간 스트리밍 처리 가능
    

즉, **신뢰성과 확장성이 필요한 데이터 파이프라인의 표준 도구**다.

---

## What is a Kafka topic?

Topic은 **메시지를 논리적으로 구분하는 카테고리**다.  
Producer는 Topic에 메시지를 쓰고, Consumer는 Topic에서 메시지를 읽는다.  
Topic 자체는 데이터를 직접 저장하지 않고, 내부적으로 **Partition**으로 나뉜다.

---

## What is a partition in Kafka?

Partition은 Topic의 **물리적 분할 단위**다.

- 병렬 처리의 핵심
    
- 각 파티션은 **순서가 보장되는 append-only 로그**
    

Kafka의 확장성과 성능은 파티션 수에 의해 결정된다.

---

## What is an offset?

Offset은 **파티션 내 메시지의 고유한 순번 ID**다.  
Consumer는 offset을 기준으로 어디까지 읽었는지 추적한다.  
Offset은 **파티션 단위**로 관리된다.

---

## What is a Kafka broker?

Broker는 Kafka 서버 인스턴스다.

- 메시지 저장
    
- Producer/Consumer 요청 처리
    
- 파티션 리더/팔로워 관리
    

여러 broker가 모여 **Kafka cluster**를 구성한다.

---

## Producer vs Consumer

- **Producer**: 메시지를 Kafka topic으로 전송
    
- **Consumer**: topic에서 메시지를 읽어 처리
    

Producer는 push, Consumer는 pull 방식으로 동작한다.

---

## What is a message in Kafka?

Message는 Kafka에서 전송되는 **데이터의 최소 단위**다.

- Key (optional)
    
- Value
    
- Timestamp
    
- Headers (optional)
    

---

## Is Kafka pull-based or push-based?

Kafka는 **Consumer pull-based 모델**이다.  
Consumer가 원하는 속도로 데이터를 가져오기 때문에 **Backpressure 제어**가 가능하다.

---

## What kind of data can Kafka handle?

- JSON
    
- Avro
    
- Protobuf
    
- Plain text
    
- Binary 데이터
    

Kafka는 **데이터 포맷에 독립적**이다.

---

# Kafka Intermediate Interview Questions

## What is a consumer group?

Consumer group은 **하나의 Topic을 협업해서 읽는 Consumer 집합**이다.  
같은 group 내에서 **하나의 파티션은 하나의 consumer만** 소비한다.

---

## Can multiple consumers read from the same partition?

- **같은 consumer group**: 불가능
    
- **다른 consumer group**: 가능
    

이 구조가 병렬성과 중복 소비를 동시에 가능하게 만든다.

---

## How does Kafka achieve scalability?

- Topic을 여러 파티션으로 분할
    
- 파티션을 여러 broker에 분산
    
- Consumer group을 통한 병렬 처리
    

---

## What is replication factor?

Replication factor는 **각 파티션이 몇 개의 복제본을 가지는지**를 의미한다.  
예: replication factor = 3 → 1 leader + 2 followers

---

## What is leader and follower in Kafka?

- **Leader**: 읽기/쓰기 처리
    
- **Follower**: leader의 데이터를 복제
    

모든 요청은 leader를 통해서만 처리된다.

---

## What is ISR (In-Sync Replicas)?

ISR은 **leader와 동기화가 유지된 replica 목록**이다.  
ISR에 속한 replica만 leader 선출 대상이 된다.

---

## What happens when a broker fails?

- 해당 broker의 leader 파티션이 down
    
- ISR 중 하나가 새로운 leader로 승격
    
- Consumer/Producer는 자동으로 새 leader로 연결
    

---

## How does Kafka ensure fault tolerance?

- 파티션 복제
    
- ISR 기반 leader election
    
- 디스크 영속 저장
    

---

## What is Zookeeper’s role in Kafka?

(ZK 기반 Kafka 기준)

- Broker 메타데이터 관리
    
- Leader election
    
- 클러스터 상태 감시
    

※ 최신 Kafka(KRaft 모드)는 Zookeeper 제거

---

## How does Kafka store messages on disk?

- Append-only 로그 파일
    
- 세그먼트 단위 저장
    
- 순차 I/O 기반 → 빠른 디스크 성능
    

---

# Kafka Advanced Interview Questions

## How does Kafka achieve exactly-once semantics?

- Idempotent Producer
    
- Transactional Producer
    
- Consumer offset을 트랜잭션에 포함
    

결과적으로 **중복 없이 정확히 한 번 처리** 보장

---

## What is an idempotent producer and why is it important?

같은 메시지를 여러 번 보내도 **브로커에 한 번만 저장**되도록 보장하는 producer.  
네트워크 재시도 시 중복 방지에 필수.

---

## Explain acks=0, acks=1, acks=all.

- acks=0: 응답 없음, 가장 빠르나 유실 가능
    
- acks=1: leader 저장 시 응답
    
- acks=all: ISR 전체 저장 후 응답 (가장 안전)
    

---

## How does Kafka handle leader election?

- ISR 중에서 새로운 leader 선출
    
- 최신 데이터 보유 replica 우선
    

---

## What happens when the ISR shrinks?

- acks=all 성능 저하
    
- min.insync.replicas 미충족 시 produce 실패 가능
    

---

## How does Kafka guarantee message ordering, and where does it fail?

- **파티션 내부에서는 순서 보장**
    
- **여러 파티션 간 순서 보장 불가**
    

---

## What is log compaction, and when should it be used?

- key 기준으로 **최신 값만 유지**
    
- 상태 저장, 이벤트 스냅샷에 사용
    

---

## Why is Kafka disk-based yet still very fast?

- 순차 쓰기
    
- OS page cache 활용
    
- zero-copy 전송
    

---

## What is zero-copy in Kafka?

디스크 → 네트워크 전송 시 **유저 공간 복사 없이 커널 레벨에서 전송**  
CPU 사용량 감소, 성능 향상

---

## How do consumer rebalances work, and how can we minimize them?

- Consumer 증감 시 파티션 재할당
    
- 처리 중단 발생 가능
    

최소화 방법:

- cooperative rebalancing
    
- session.timeout 조정
    
- static membership 사용
    

---

# Kafka Scenario-Based Questions

## Why is my consumer not receiving messages?

- 잘못된 consumer group
    
- offset이 이미 최신
    
- 파티션 수 < consumer 수
    

---

## How can a consumer read old messages?

- auto.offset.reset=earliest
    
- offset 수동 reset
    

---

## What happens if a consumer crashes?

- 파티션 재할당
    
- 다른 consumer가 offset 이후부터 처리
    

---

## What happens if producer sends duplicate messages?

- 기본 설정: 중복 가능
    
- idempotent producer 사용 시 방지
    

---

## How does Kafka maintain message ordering?

- key 기반 파티션 할당
    
- 파티션 내부 순서 보장
    


